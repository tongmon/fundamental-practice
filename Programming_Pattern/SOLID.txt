1. 단일 책임 원칙 (SRP)
메모장 프로그램을 예시로 들어보자. 
일단 메모장에서 텍스트 편집에 관여하는 기능을 담당하는 클래스가 있어야 할 것이다.
저장 기능도 있어야 할 것이다. 
텍스트 편집 클래스에 저장 기능을 넣어야 할까?
저장이라는 것이 하드디스크에 저장하는 것 뿐만 아니라 클라우드에 올릴 수도 있지 않은가?
만약 저장 기능을 텍스트 편집 클래스에 넣게 되면 저장 방식이 추가될 때마다 확장하기도 귀찮고 직관적으로 구성하기도 힘들 것이다.
이런 경우에는 그냥 편집 관련 작업만 해주는 텍스트 편집 클래스와 저장 관련 작업만 해주는 저장 클래스를 따로 나누어 상호작용 시키는 것이 좋다.

밑은 단일 책임 원칙 위배 예시
class NotePad {
    Editor m_Edit;
};

class Editor {
   public:
    void DoEdit();
    void SaveToDisk();
    void SaveToCloud();
    void SaveToCustomServer();
};

밑은 단인 책임 원칙을 준수하는 예시
class NotePad {
    Editor m_Edit;
    Saver m_Saver;
};

class Editor {
   public:
    void DoEdit();
};

class Saver {
   public:
    void SaveToDisk(Editor& edit);
    void SaveToCloud(Editor& edit);
    void SaveToCustomServer(Editor& edit);
};

2. 열림 닫힘 원칙 (OCP)
확장에는 열려있지만 수정에는 닫혀있어야 하는 원칙이다.
필터링을 해주는 프로그램을 개발한다고 해보자.
코드는 일단 밑과 같다.

enum class Color { Red, Green, Blue };
enum class Size { Small, Medium, Large };

class Product {
   public:
    Color color;
    Size size;
};

여기서 고객은 색상으로 물건을 나누길 원한다. 그러면 함수는 밑과 같은 형태를 취할 것이다.
std::vector<Product> filter_by_color(const std::vector<Product>& items, Color color) {
    std::vector<Product> ret_items;
    std::for_each(items.begin(), items.end(),
                  [&](const auto& item) -> void {
                      if (item.color == color)
                          ret_items.push_back(item);
                  });
    return ret_items;
}

그런데 고객이 크기에 따라 물건을 나누길 원한다. 함수를 추가해야 한다.
std::vector<Product> filter_by_size(const std::vector<Product>& items, Size size) {
    std::vector<Product> ret_items;
    std::for_each(items.begin(), items.end(),
                  [&](const auto& item) -> void {
                      if (item.size == size)
                          ret_items.push_back(item);
                  });
    return ret_items;
}

그런데 고객이 크기와 색상을 동시에 따져 물건을 나누길 원한다. 또 함수를 추가해야 한다...
std::vector<Product> filter_by_color_and_size(const std::vector<Product>& items, Color color, Size size) {
    std::vector<Product> ret_items;
    std::for_each(items.begin(), items.end(),
                  [&](const auto& item) -> void {
                      if (item.size == size && item.color == color)
                          ret_items.push_back(item);
                  });
    return ret_items;
}

만약 물건에 색상과 크기 말고 다른 속성이 생기고 고객이 또 그에 따른 필터 요구사항을 추가한다면 점점 더 복잡해질 뿐이다.
이는 지금 현재 코드 구조가 열림 닫힘 원칙을 지키지 않아서이다.
밑의 코드는 열림 닫힘 원칙을 지킨 예시이다.

일단 색상에 따라, 크기에 따라, 색상과 크기에 따라... 이렇게 나눠지는 현상을 직관화하기 위해서 명세라는 템플릿 클래스로 따로 뺀다.
template <typename T>
class Sepcification {
  public:
    virtual bool is_specified(const T &item) = 0;
};

필터를 더 유연하게 만든 템플릿 필터 클래스를 만든다.
template <typename T>
class Filter {
    virtual std::vector<T> filter(const std::vector<T> &items, Sepcification<T> &spec) = 0;
};

위 두 템플릿을 이용해 필터를 짜보면 밑과 같다.
class BetterFilter : public Filter<Product> {
  public:
    std::vector<Product> filter(const std::vector<Product> &items, Sepcification<Product> &spec) {
        std::vector<Product> ret_items;
        std::for_each(items.begin(), items.end(),
                      [&](const auto &item) -> void {
                          if (spec.is_specified(item))
                              ret_items.push_back(item);
                      });
        return ret_items;
    }
};
이렇게 하면 예전에 함수 인자와 내부 로직이 난잡하게 계속 변했던 것과 비교하면 명세와 필터의 기능이 명확하게 분리가 되어 코드 짜기가 수월해진다.
filter 함수는 그대로고 
