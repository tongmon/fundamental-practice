빌더 패턴은 객체를 쉽게 처리하기 위한 패턴이다.
여러가지 빌더 패턴 스타일이 존재한다.

일단 밑과 같이 간단한 XmlWriter 클래스가 있다고 하자. (xml을 실제 std::string으로 변환해주는 str() 함수 내부 로직은 지금 중요하지 않으니 신경쓸 필요 없다.)
class XmlWriter {
    std::string content;
    std::string tag;

  public:
    std::vector<XmlWriter> element;

    XmlWriter(const std::string &tag = "", const std::string &content = "") {
        this->tag = tag, this->content = content;
    }
    ~XmlWriter() {}

    std::string str(const std::string &tabs = "") const {
        std::string content_from_element, content_modified;

        if (!element.empty()) {
            for (const auto &item : element)
                content_from_element += item.str(tabs + "\t") + "\n";
            content_from_element.pop_back();
        } else
            content_modified = std::regex_replace(tabs + "\t" + content, std::regex("\n"), "\n" + tabs + "\t");

        return tabs + "<" + tag + ">\n" + (element.empty() ? content_modified : content_from_element) + "\n" + tabs + "</" + tag + ">";
    }
};

이 상태에서 XmlWriter를 활용하려면 밑과 같이 코드를 구성해야 할 것이다.
XmlWriter xml{"Zoo", ""};
xml.element.push_back(XmlWriter{"Water", "Fish"});
xml.element.push_back(XmlWriter{"Ground", XmlWriter("Horse", "Zebra").str()});
std::cout << xml.str() << "\n";

그러면 대략 밑과 같이 출력이 될 것이다.
<Zoo>
        <Water>
                Fish
        </Water>
        <Ground>
                <Horse>
                        Zebra
                </Horse>
        </Ground>
</Zoo>

XmlWriter 클래스를 활용하는 코드의 구성을 보면 xml 객체에서 element를 가져와서 push_back을 하는 코드도 난잡해 보이고, 겹겹이 쌓이는 정보를 넣을 때 XmlWriter("Something", XmlWriter("Something", XmlWriter("Something", "Something").str()).str()).str() 요런식으로 넣어줘야 하기 때문에 산만하다.
이를 해결하는 방법들을 알아보자

1. 단순한 빌더
객체 생성 역할을 맡는 다른 클래스를 별도로 만들어서 처리한다.

Xml 객체 생성을 해주는 XmlBuilder 클래스를 밑과 같이 정의한다.
class XmlBuilder {
    XmlWriter root;

  public:
    XmlBuilder(std::string root_tag) { root = XmlWriter(root_tag, ""); }
    ~XmlBuilder() {}
	
    void add_child(const std::string &tag, const std::string &content) {
        root.element.push_back(XmlWriter{tag, content});
    }
    std::string str() { return root.str(); }
};

빌더 클래스를 활용해 xml 스트링 값을 출력하는 코드를 보면 밑과 같다.
XmlBuilder builder("Zoo");
builder.add_child("Water", "Fish");
builder.add_child("Ground", XmlWriter("Horse", "Zebra").str());
std::cout << builder.str() << "\n";

조금 간결하고 직관적이게 되었지만 아직 난잡해 보인다.

2. 흐름식 빌더
객체 생성을 하는 함수에서 객체를 반환하는 형태를 갖춘다.

일단 XmlWriter 클래스에 밑과 같은 public 멤버 함수 add_child()를 추가해준다.
XmlWriter &add_child(const std::string &tag, const std::string &content) {
    element.push_back(XmlWriter{tag, content});
    return element.back();
}

XmlBuilder 클래스에서 add_child() 함수를 밑과 같이 변형시켜준다.
XmlWriter &add_child(const std::string &tag, const std::string &content) {
    root.element.push_back(XmlWriter{tag, content});
    return root.element.back();
}

이렇게 되면 밑과 같이 xml 스트링 값을 출력할 수 있다.
XmlBuilder builder("Zoo");
builder.add_child("Water", "Fish");
builder.add_child("Ground", "").add_child("Horse", "Zebra");
std::cout << builder.str() << "\n";

객체 생성을 연달아 할 수 있어 생성자를 이용해 껴넣는 단순 빌더 방식보다 직관성이 많이 좋아졌다.

2-1. XmlBuilder 클래스 무조건 이용하게 만들기
사용자가 xml 클래스를 사용할 때 XmlWriter도 사용하고 XmlBuilder도 사용할 수 있으면 혼동이 올 수도 있고 충분히 XmlBuilder 클래스로 모든 작업이 가능하다면 굳이 사용자에게 XmlWriter 클래스를 제공해줄 필요가 없다. 이러한 경우 사용자가 XmlBuilder만 사용하도록 코드를 구성해야 한다.

생각보다 좀 복잡한 단계를 거쳐야 한다.
일단 기존에 main.cpp에서 모두 처리하던 코드들을 .h, .cpp 파일들로 전방선언, 불완전한 반환값 문제를 방지하기 위해 분리해야 한다.

xmlwriter.h의 코드 내용이다. (헤더 가드와 각종 #include 들은 제외한다.)
class XmlBuilder;

class XmlWriter {
    std::string content;
    std::string tag;

  protected:
    XmlWriter(const std::string &tag = "", const std::string &content = "");

  public:
    ~XmlWriter() {}

    std::vector<XmlWriter> element;

    XmlWriter &add_child(const std::string &tag, const std::string &content);

    std::string str(const std::string &tabs = "") const;

    // static XmlBuilder &&build(const std::string &tag);

    static std::unique_ptr<XmlBuilder> build(const std::string &tag);
};
일단 잘 봐야되는 것은 생성자가 protected로 사용자가 못쓰게 가려졌다는 것이다. 이것으로 인해 사용자는 강제로 특정 인터페이스를 통해서만 xml 정보를 구축할 수 있다. (소멸자가 public에 남겨진 이유는 추후에 설명한다.)
또 다른 중요한 점은 전역 클래스 멤버 함수로 build라는 함수가 추가되었는데 이는 사용자가 유일하게 XmlBuilder 클래스를 획득할 수 있는 인터페이스다. 즉 사용자는 해당 함수를 사용하지 않고서는 xml 정보를 구축할 수 없다.
사용자는 이제 빌더를 생성할 때 XmlWriter::build("Zoo") 요런식으로 접근하게 된다.
주석 처리된 코드와 같이 std::move()를 사용하는 &&를 사용해도 된다. 단지 개발자의 취향이다.

xmlwriter.cpp의 코드 내용이다.
XmlWriter::XmlWriter(const std::string &tag, const std::string &content) {
    this->tag = tag, this->content = content;
}

std::string XmlWriter::str(const std::string &tabs) const {
    std::string content_from_element, content_modified;

    if (!element.empty()) {
        for (const auto &item : element)
            content_from_element += item.str(tabs + "\t") + "\n";
        content_from_element.pop_back();
    } else
        content_modified = std::regex_replace(tabs + "\t" + content, std::regex("\n"), "\n" + tabs + "\t");

    return tabs + "<" + tag + ">\n" + (element.empty() ? content_modified : content_from_element) + "\n" + tabs + "</" + tag + ">";
}

XmlWriter &XmlWriter::add_child(const std::string &tag, const std::string &content) {
    element.push_back(XmlWriter{tag, content});
    return element.back();
}

/*
XmlBuilder &&XmlWriter::build(const std::string &tag) {
    XmlWriter *writer = new XmlWriter(tag, "");
    return std::move(XmlBuilder(writer));
}
*/

std::unique_ptr<XmlBuilder> XmlWriter::build(const std::string &tag) {
    XmlWriter *writer = new XmlWriter(tag, "");
    return std::make_unique<XmlBuilder>(writer);
}
build 함수의 구현부는 별 특이한게 없이 간단한데 추후에 설명하겠지만 XmlBuilder의 생성자가 바뀌었다.

xmlbuilder.h의 코드 내용이다.
class XmlBuilder {
    XmlWriter *root;

  public:
    XmlBuilder(XmlWriter *writer) {
        root = writer;
    }
    ~XmlBuilder() { delete root; }
    operator XmlWriter() const { return *root; }
    XmlWriter &add_child(const std::string &tag, const std::string &content);
    std::string str() {
        return root->str();
    }
};
중요하게 바뀐 것은 XmlBuilder에서도 XmlWriter의 생성자로 접근하지 못하여 이제 root를 포인터형으로 가지고 있어야 한다. 그리고 사용자는 XmlBuilder를 생성할 때 XmlWriter::build() 함수를 이용하게 된다.