빌더 패턴은 객체를 쉽게 처리하기 위한 패턴이다.
여러가지 빌더 패턴 스타일이 존재한다.

일단 밑과 같이 간단한 XmlWriter 클래스가 있다고 하자. (xml을 실제 std::string으로 변환해주는 str() 함수 내부 로직은 지금 중요하지 않으니 신경쓸 필요 없다.)
class XmlWriter {
    std::string content;
    std::string tag;

  public:
    std::vector<XmlWriter> element;

    XmlWriter(const std::string &tag, const std::string &content) {
        this->tag = tag, this->content = content;
    }
    ~XmlWriter() {}

    std::string str(const std::string &tabs = "") const {
        std::string content_from_element, content_modified;

        if (!element.empty()) {
            for (const auto &item : element)
                content_from_element += item.str(tabs + "\t") + "\n";
            content_from_element.pop_back();
        } else
            content_modified = std::regex_replace(tabs + "\t" + content, std::regex("\n"), "\n" + tabs + "\t");

        return tabs + "<" + tag + ">\n" + (element.empty() ? content_modified : content_from_element) + "\n" + tabs + "</" + tag + ">";
    }
};

이 상태에서 XmlWriter를 활용하려면 밑과 같이 코드를 구성해야 할 것이다.
XmlWriter xml{"Zoo", ""};
xml.element.push_back(XmlWriter{"Water", "Fish"});
xml.element.push_back(XmlWriter{"Ground", XmlWriter("Horse", "Zebra").str()});
std::cout << xml.str() << "\n";

그러면 대략 밑과 같이 출력이 될 것이다.
<Zoo>
        <Water>
                Fish
        </Water>
        <Ground>
                <Horse>
                        Zebra
                </Horse>
        </Ground>
</Zoo>

XmlWriter 클래스를 활용하는 코드의 구성을 보면 xml 객체에서 element를 가져와서 push_back을 하는 코드도 난잡해 보이고, 겹겹이 쌓이는 정보를 넣을 때 XmlWriter("Something", XmlWriter("Something", XmlWriter("Something", "Something").str()).str()).str() 요런식으로 넣어줘야 하기 때문에 산만하다.