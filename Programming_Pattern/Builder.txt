빌더 패턴은 객체를 쉽게 처리하기 위한 패턴이다.
여러가지 빌더 패턴 스타일이 존재한다.

일단 밑과 같이 간단한 XmlWriter 클래스가 있다고 하자. (xml을 실제 std::string으로 변환해주는 str() 함수 내부 로직은 지금 중요하지 않으니 신경쓸 필요 없다.)
class XmlWriter {
    std::string content;
    std::string tag;

  public:
    std::vector<XmlWriter> element;

    XmlWriter(const std::string &tag = "", const std::string &content = "") {
        this->tag = tag, this->content = content;
    }
    ~XmlWriter() {}

    std::string str(const std::string &tabs = "") const {
        std::string content_from_element, content_modified;

        if (!element.empty()) {
            for (const auto &item : element)
                content_from_element += item.str(tabs + "\t") + "\n";
            content_from_element.pop_back();
        } else
            content_modified = std::regex_replace(tabs + "\t" + content, std::regex("\n"), "\n" + tabs + "\t");

        return tabs + "<" + tag + ">\n" + (element.empty() ? content_modified : content_from_element) + "\n" + tabs + "</" + tag + ">";
    }
};

이 상태에서 XmlWriter를 활용하려면 밑과 같이 코드를 구성해야 할 것이다.
XmlWriter xml{"Zoo", ""};
xml.element.push_back(XmlWriter{"Water", "Fish"});
xml.element.push_back(XmlWriter{"Ground", XmlWriter("Horse", "Zebra").str()});
std::cout << xml.str() << "\n";

그러면 대략 밑과 같이 출력이 될 것이다.
<Zoo>
        <Water>
                Fish
        </Water>
        <Ground>
                <Horse>
                        Zebra
                </Horse>
        </Ground>
</Zoo>

XmlWriter 클래스를 활용하는 코드의 구성을 보면 xml 객체에서 element를 가져와서 push_back을 하는 코드도 난잡해 보이고, 겹겹이 쌓이는 정보를 넣을 때 XmlWriter("Something", XmlWriter("Something", XmlWriter("Something", "Something").str()).str()).str() 요런식으로 넣어줘야 하기 때문에 산만하다.
이를 해결하는 방법들을 알아보자

1. 단순한 빌더
객체 생성 역할을 맡는 다른 클래스를 별도로 만들어서 처리한다.

Xml 객체 생성을 해주는 XmlBuilder 클래스를 밑과 같이 정의한다.
class XmlBuilder {
    XmlWriter root;

  public:
    XmlBuilder(std::string root_tag) { root = XmlWriter(root_tag, ""); }
    ~XmlBuilder() {}
	
    void add_child(const std::string &tag, const std::string &content) {
        root.element.push_back(XmlWriter{tag, content});
    }
    std::string str() { return root.str(); }
};

빌더 클래스를 활용해 xml 스트링 값을 출력하는 코드를 보면 밑과 같다.
XmlBuilder builder("Zoo");
builder.add_child("Water", "Fish");
builder.add_child("Ground", XmlWriter("Horse", "Zebra").str());
std::cout << builder.str() << "\n";

조금 간결하고 직관적이게 되었지만 아직 난잡해 보인다.

2. 흐름식 빌더
객체 생성을 하는 함수에서 객체를 반환하는 형태를 갖춘다.

XmlBuilder 클래스에서 add_child() 함수를 밑과 같이 변형시켜준다.
XmlBuilder &XmlBuilder::add_child(const std::string &tag, const std::string &content) {
    root.element.push_back(XmlWriter{tag, content});
    return *this;
}

이렇게 되면 밑과 같이 xml 스트링 값을 출력할 수 있다.
XmlBuilder builder("Zoo");
builder.add_child("Water", "Fish").add_child("Ground", XmlWriter{"Horse", "Zebra"}.str());
std::cout << builder.str() << "\n";

Xml 정보 추가를 연달아 할 수 있어 단순 빌더 방식보다 호출 코드도 짧고 직관적이다.

2-1. 사용자 인터페이스 통합하기
사용자가 xml 클래스를 사용할 때 XmlWriter도 사용하고 XmlBuilder도 사용할 수 있으면 혼동이 올 수 있다.
사용자가 xml 정보를 생성하고 출력하는데만 집중할 수 있도록 직관적으로 인터페이스를 제공해야한다.

생각보다 좀 복잡한 단계를 거쳐야 한다.
일단 기존에 main.cpp에서 모두 처리하던 코드들을 .h, .cpp 파일들로 전방선언, 불완전한 반환값 문제를 방지하기 위해 분리해야 한다.

xmlwriter.h의 코드 내용이다. (헤더 가드와 각종 #include 들은 제외한다.)
class XmlBuilder;

class XmlWriter {
    std::string content;
    std::string tag;
    friend class XmlBuilder;

  protected:
    XmlWriter(const std::string &tag = "", const std::string &content = "");

  public:
    ~XmlWriter() {}

    std::vector<XmlWriter> element;

    std::string str(const std::string &tabs = "") const;

    static XmlBuilder build(const std::string &tag);

    static std::string str(const std::string &tag, const std::string &content);
};
일단 잘 봐야되는 것은 생성자가 protected로 사용자가 못쓰게 가려졌다는 것이다. 이것으로 인해 사용자는 강제로 특정 인터페이스를 통해서만 xml 정보를 구축할 수 있다.
반면에 XmlBuilder 클래스는 친구 클래스로 선언 되었기에 XmlWriter의 생성자를 이용할 수 있다.
또 다른 중요한 점은 전역 클래스 멤버 함수가 build, str 두개 있는데 사용자가 사용할 수 있는 xml 생성 인터페이스가 build()이고 자식 노드를 추가하기 위한 인터페이스가 str()이다.
이제 xml 정보를 생성할 때 XmlWriter::build("Zoo") 요런식으로 접근하게 된다.
xml 자식 노드를 생성할 때 XmlWriter::str("Horse", "Zebra") 이렇게 접근할 수 있다.

xmlwriter.cpp의 코드 내용이다.
XmlWriter::XmlWriter(const std::string &tag, const std::string &content) {
    this->tag = tag, this->content = content;
}

std::string XmlWriter::str(const std::string &tabs) const {
    std::string content_from_element, content_modified;

    if (!element.empty()) {
        for (const auto &item : element)
            content_from_element += item.str(tabs + "\t") + "\n";
        content_from_element.pop_back();
    } else
        content_modified = std::regex_replace(tabs + "\t" + content, std::regex("\n"), "\n" + tabs + "\t");

    return tabs + "<" + tag + ">\n" + (element.empty() ? content_modified : content_from_element) + "\n" + tabs + "</" + tag + ">";
}

XmlBuilder XmlWriter::build(const std::string &tag) {
    XmlWriter *writer = new XmlWriter(tag, "");
    return XmlBuilder(writer);
}

std::string XmlWriter::str(const std::string &tag, const std::string &content) {
    return XmlWriter(tag, content).str();
}
build 함수의 구현부는 별 특이한게 없이 간단한데 추후에 설명하겠지만 build() 함수에서 볼 수 있듯이 XmlBuilder의 생성자가 바뀌었다.

xmlbuilder.h의 코드 내용이다.
class XmlBuilder {
    XmlWriter *root;

  public:
    XmlBuilder(XmlWriter *writer) {
        root = writer;
    }
    ~XmlBuilder() { delete root; }
    operator XmlWriter() const { return *root; }
    XmlBuilder &add_child(const std::string &tag, const std::string &content);
    std::string str() {
        return root->str();
    }
};
중요하게 바뀐 것은 XmlBuilder에서도 XmlWriter의 생성자로 접근하지 못하여 이제 root를 포인터형으로 가지고 있어야 한다. 그리고 사용자는 XmlBuilder를 생성할 때 XmlWriter::build() 함수를 이용하게 된다.

xmlbuilder.cpp의 코드 내용이다.
XmlBuilder &XmlBuilder::add_child(const std::string &tag, const std::string &content) {
    root->element.push_back(XmlWriter{tag, content});
    return *this;
}