explicit
암시적 변환 금지 시킴, 암시적 복사 생성자 호출 금지
예시) 
long p = 3;
char K = p; 이건 가능하지만 만약에서 long 형 변환에 explicit이 붙어있다면 컴파일러는 에러를 내뿜는다.
char K = long(p); 이렇게 해야 에러 없이 진행 가능하다.
즉 모든 것을 명시적으로 하게 만드려면 함수나 생성자 앞에 explicit을 붙이면 된다.

mutable
밑과 같은 클래스 const 함수는 클래스 내의 멤버 변수를 바꿀 수 없다.
void DoSomething(int x) const { }
하지만 클래스 내의 멤버 변수가 mutable int a; 이렇게 mutable이 붙어 선언이 되었다면 클래스 const 함수 내에서 멤버 변수를 바꿀 수 있다.
이런 애를 쓰는 이유는 이 함수를 사용하는 인터페이스로 보아서는 const가 붙어야 하는데 내부적으로 클래스 멤버 변수를 변경해야 하는 함수면 이를 사용한다.

형변환
static_cast<int>(float_variable); <=> (int)(float_variable)

dyanmic_cast
상속 관계에 있는 두 포인터 간에 캐스팅을 해줌 (static_cast<> 와 다르게 오류 찾기 쉬워서 씀)

보통 함수 호출보다 virtual이 붙은 함수 호출하는 시간이 더 오래걸린다.
클래스 포인터 다룰 때 항상 더 큰 녀석(자식)을 더 작은 녀석(부모)에게 줄 수 있다는 것을 인지하자 (그 반대는 안된다.)
다이아몬드 상속 문제(다중 상속에서 발생하는 문제)를 해결하는 virtual 상속에 대해 기억하기!

탬풀릿 사용시에는 template <class T>보다는 template <typename T> 이용하기

함수는 아니지만 함수인 척을 하는 녀석 Funtor
예시)
struct Comp {
  bool operator()(int a, int b) { return a > b; }
};
Comp compare;
int a = 3, b = 1;
cout << compare(a, b);
이런 짓이 가능해서 템플릿 프로그래밍에서 비교연산자 재정의해서 쓰기보다 이러한 Funtor를 넘겨 오름차순, 내림차순을 바꾸게 된다.

템플릿 template <typename T, int num = 5> 이런 문법 가능

대표적인 쓰임새 예시)

template <typename T>
struct Compare {
  bool operator()(const T& a, const T& b) const { return a < b; }
};

template <typename T, typename Comp = Compare<T>>
T Min(T a, T b) {
  Comp comp;
  if (comp(a, b)) {
    return a;
  }
  return b;
}

템플릿 함수를 작성할 때 그 순서에 유의할 것.

#define SIZE 10 // C-style
constexpr int size = 10; // modern C++

C++17의 Fold 기법

템플릿 메타 프로그래밍에서 들어가는 인수는 상수여야 한다.

밑과 같은 경우가 템플릿 메타 프로그래밍인데 여기서 함수 인자와 같이 들어가게 되는 N은 무조건 const 형과 같은 상수여야 한다.
template <int N>
struct Factorial {
	static const int result = N * Factorial<N - 1>::result;
};

template <>
struct Factorial<1> {
	static const int result = 1;
};

Factorial<k>::result
여기서 k는 상수가 아니면 에러다. 템플릿 메타 프로그래밍은 무조건 컴파일 시간에 결정될 수 있는 것만 가능하다.

typedef vector<int> VecInt;
using VecInt = vector<int>;

typedef void (*func)(int, int);
using func = void (*)(int, int);

함수 객체(Funtor)에는 절대로 특정 상태를 저장해서 이에 따라 결과가 달라지는 루틴을 짜면 안된다.
이는 C++ 컴파일러마다 STL 인터페이스는 같지만 구현 방식이 천차만별이기 때문이다.

람다 활용성
vec.erase(std::remove_if(vec.begin(), vec.end(), [](int i) -> bool { return i % 2 == 1; })
위와 같이 "벡터에서 홀수인 원소 지우기"를 수행하는 코드를 간결하게 작성가능하다.

lvalue(좌측값) rvalue(우측값)에 대한 정의
좌측값 = 대입 시에 왼쪽 혹은 오른쪽에 오는 식, ex) int p; int a = p; -> a, p 모두 좌측값
추가적으로 좌측값은 어떠한 메모리 위치를 가리키고 있는 값이라고도 볼 수 있다.
우측값 = 대입 시에 오직 오른쪽에만 오는 식, ex) int a = 3; -> 여기서 3이 우측값 / int q, p; int a = p * q; -> 여기서 p * q 는 우측값
int func() { int a = 1; return a; } -> 여기서 func()는 우측값이다. 왜냐하면 func() = 3; 이건 불가능하기 때문

&는 좌측값 참조다.
잘 알다싶이 다음 예시와 같이 보통 쓰임
void StringFunc(string &str) { str = "changed"; }
void StringFunc(const string &str) { cout << "str is const var" << endl; }

&&는 우측값 참조다.
int &b = 3; 이렇게 사용은 안되지만 int &&b = 3; 이런 표현은 가능하다.
int p = 1, q = 2; int &&b = p + q; 이런 임시 우측값을 담는 표현도 가능하다.
우측값 참조의 대표적인 쓰임은 컴파일러로 하여금 컴파일 시간에 어떤 인자로 좌측값이 오는지 우측값이 오는지에 따라 오버로딩을 할 수 있도록 도와주는 것이다.
기본적으로 int p = 1;을 수행하면 값 1은 p에 복사되고 1에 필요한 메모리는 없어진다.
반면 int &&p = 1;을 수행하면 값 1에 필요한 메모리는 사라지지 않고 이 메모리를 p는 가리키게 된다. 
마치 1에 temp라는 별명을 쥐어주고 temp를 가리키는 것과 같다.
int temp = 1; int &p = temp; 이 코드와 비슷한 효과를 낸다. (물론 우측값 참조는 int temp = 1; 이러한 과정이 없으므로 더 빠르다.)
int &a = b + c -> 불가능
int &&a = b + c -> 가능, 속도 빠름
int a = b + c -> 가능, 속도 느림
우측값 참조로 된 a는 b + c 의 결과가 반영된 임시객체를 가리키게 된다.
속도가 빨라지는 이유는 int a = b + c 이 경우 b + c 결과가 a에 복사된다.
연산 순서는 b + c 연산 후 객체 생성 -> b + c 객체를 a로 복사 -> b + c 객체 파괴 이렇게 3번의 연산이 이루어진다. 
반면 int &&a = b + c 의 연산 순서를 보면 b + c 연산 후 객체 생성 -> a는 b + c 객체를 참조 이렇게 복사가 이루어지는 곳이 없이 순조롭게 연산이 끝난다.
간단히 &&는 우측값의 생명 주기를 연장해준다고 생각하면 된다.

class Mover
{
	int m_var;
public:
	void func(int a) { m_var = a; }
	void func(int& a) { m_var = a; }
	void func(const int& a) { m_var = a; }
	void func(int&& a) { m_var = a; }
};
위와 같은 클래스에서 4가지 func를 비교해보겠다.

1. void func(int a) { m_var = a; }
함수 인자를 받을 때 a로 값이 복사되어 한 번 복사가 발생되고 m_var에 a 값을 옮기는 과정에서 복사 한 번이 더 발생한다.
총 복사: 2번

2. void func(int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
인자로 좌측값만 받을 수 있다.
총 복사: 1번

3. void func(const int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다. (a는 const로 변경불가 할 뿐 참조로 받은 것이다.)
인자로 우측값과 좌측값 모두 받을 수 있다.
총 복사: 1번

4. void func(int&& a) { m_var = a; }
여기서 주의할 것은 int&& a에서 a는 좌측값이다. (a라는 별명, 즉 실체가 있을 때는 좌측값으로 취급된다.)
좌측값 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
총 복사: 1번

2, 3, 4번은 모두 복사가 1번 이루어지는데 사용하는 이유가 있다.
2번은 좌측값만 취급하기에 func(1) 과 같은 것을 다루지 못한다.
3번은 func(1), func(p) 좌측, 우측값을 모두 다루지만 함수 내부에서 값 변경을 할 수 없다.
4번은 func(1), func(1+2) 등 우측값을 다룰 수 있고 내부에서 함수 인자를 바꿀 수도 있다. (밑의 함수 처럼 말이다.)
void func(int&& a) { a = 3; m_var = a; } -> func(100)을 해도 m_var = 3이다.
보통 함수 인자 넘길 때 복사가 발생하지 않게 하기 위해서는 밑과 같이 우측값 참조자를 사용한 것과 그냥 참조자를 사용한 것 두 가지를 모두 정의한다. (이러면 좌측값, 우측값이 모두 의도한 데로 커버된다.)
void func(int&& a) { m_var = a; }; void func(int& a) { m_var = a; }

우측값 참조를 효율적으로 이용하기 위한 move()

template <typename T>
void swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}
해당 함수를 보면 복사가 3번 발생한다.
생성자가 복사 생성자라 복사 발생 -> 1
a = b에서 복사 발생 -> 2
b = tmp에서 복사 발생 -> 3
복사가 총 3번 발생하는데 자료형 T의 크기가 크면 클수록 속도가 많이 느려질 것이다.

template <typename T>
void swap(T &a, T &b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}
복사가 발생하는 구간이 없이 모두 이동 생성이다.
복사 생성보다는 이동 생성이 빠르고 좌측값을 우측값으로 바꾸어 이동 생성을 가능하게 하는 것이 바로 move() 함수이다.
물론 이렇게 이동 생성으로 득을 보려면 자료형 T에 T& T::operator=(T&& s) 이러한 

move() 예시를 좀 더 들어보면 우측값 참조는 우측값 + 참조이다.
void func(int&& a) { a = 3; }
int q = 3;
int &p = q;
func(move(p));
여기서 q, p의 값은 모두 3이다. 우측값으로 넘겨주었지만 참조라 값이 변한 것이 원본에 영향을 미친다.

int q = 1;
func(move(q));
이것도 마찬가지로 q의 값은 3이다. 우측값으로 넘겼지만 참조라 q의 값이 func() 함수 때문에 변한다.