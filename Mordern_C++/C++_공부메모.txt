explicit
암시적 변환 금지 시킴, 암시적 복사 생성자 호출 금지
예시) 
long p = 3;
char K = p; 이건 가능하지만 만약에서 long 형 변환에 explicit이 붙어있다면 컴파일러는 에러를 내뿜는다.
char K = long(p); 이렇게 해야 에러 없이 진행 가능하다.
즉 모든 것을 명시적으로 하게 만드려면 함수나 생성자 앞에 explicit을 붙이면 된다.

mutable
밑과 같은 클래스 const 함수는 클래스 내의 멤버 변수를 바꿀 수 없다.
void DoSomething(int x) const { }
하지만 클래스 내의 멤버 변수가 mutable int a; 이렇게 mutable이 붙어 선언이 되었다면 클래스 const 함수 내에서 멤버 변수를 바꿀 수 있다.
이런 애를 쓰는 이유는 이 함수를 사용하는 인터페이스로 보아서는 const가 붙어야 하는데 내부적으로 클래스 멤버 변수를 변경해야 하는 함수면 이를 사용한다.

형변환
static_cast<int>(float_variable); <=> (int)(float_variable)

dyanmic_cast
상속 관계에 있는 두 포인터 간에 캐스팅을 해줌 (static_cast<> 와 다르게 오류 찾기 쉬워서 씀)

보통 함수 호출보다 virtual이 붙은 함수 호출하는 시간이 더 오래걸린다.
클래스 포인터 다룰 때 항상 더 큰 녀석(자식)을 더 작은 녀석(부모)에게 줄 수 있다는 것을 인지하자 (그 반대는 안된다.)
다이아몬드 상속 문제(다중 상속에서 발생하는 문제)를 해결하는 virtual 상속에 대해 기억하기!

탬풀릿 사용시에는 template <class T>보다는 template <typename T> 이용하기

함수는 아니지만 함수인 척을 하는 녀석 Funtor
예시)
struct Comp {
  bool operator()(int a, int b) { return a > b; }
};
Comp compare;
int a = 3, b = 1;
cout << compare(a, b);
이런 짓이 가능해서 템플릿 프로그래밍에서 비교연산자 재정의해서 쓰기보다 이러한 Funtor를 넘겨 오름차순, 내림차순을 바꾸게 된다.

템플릿 template <typename T, int num = 5> 이런 문법 가능

대표적인 쓰임새 예시)

template <typename T>
struct Compare {
  bool operator()(const T& a, const T& b) const { return a < b; }
};

template <typename T, typename Comp = Compare<T>>
T Min(T a, T b) {
  Comp cmp;
  if (cmp(a, b)) {
    return a;
  }
  return b;
}

템플릿 함수를 작성할 때 그 순서에 유의할 것.

#define SIZE 10 // C-style
constexpr int size = 10; // modern C++

C++17의 Fold 기법

템플릿 메타 프로그래밍에서 들어가는 인수는 상수여야 한다.

밑과 같은 경우가 템플릿 메타 프로그래밍인데 여기서 함수 인자와 같이 들어가게 되는 N은 무조건 const 형과 같은 상수여야 한다.
template <int N>
struct Factorial {
	static const int result = N * Factorial<N - 1>::result;
};

template <>
struct Factorial<1> {
	static const int result = 1;
};

Factorial<k>::result
여기서 k는 상수가 아니면 에러다. 템플릿 메타 프로그래밍은 무조건 컴파일 시간에 결정될 수 있는 것만 가능하다.

typedef vector<int> VecInt;
using VecInt = vector<int>;

typedef void (*func)(int, int);
using func = void (*)(int, int);

함수 객체(Funtor)에는 절대로 특정 상태를 저장해서 이에 따라 결과가 달라지는 루틴을 짜면 안된다.
이는 C++ 컴파일러마다 STL 인터페이스는 같지만 구현 방식이 천차만별이기 때문이다.

람다 활용성
vec.erase(std::remove_if(vec.begin(), vec.end(), [](int i) -> bool { return i % 2 == 1; })
위와 같이 "벡터에서 홀수인 원소 지우기"를 수행하는 코드를 간결하게 작성가능하다.

lvalue(좌측값) rvalue(우측값)에 대한 정의
좌측값 = 대입 시에 왼쪽 혹은 오른쪽에 오는 식, ex) int p; int a = p; -> a, p 모두 좌측값
추가적으로 좌측값은 어떠한 메모리 위치를 가리키고 있는 값이라고도 볼 수 있다.
우측값 = 대입 시에 오직 오른쪽에만 오는 식, ex) int a = 3; -> 여기서 3이 우측값 / int q, p; int a = p * q; -> 여기서 p * q 는 우측값
int func() { int a = 1; return a; } -> 여기서 func()는 우측값이다. 왜냐하면 func() = 3; 이건 불가능하기 때문

&는 좌측값 참조다.
잘 알다싶이 다음 예시와 같이 보통 쓰임
void StringFunc(string &str) { str = "changed"; }
void StringFunc(const string &str) { cout << "str is const var" << endl; }

&&는 우측값 참조다.
int &b = 3; 이렇게 사용은 안되지만 int &&b = 3; 이런 표현은 가능하다.
int p = 1, q = 2; int &&b = p + q; 이런 임시 우측값을 담는 표현도 가능하다.
우측값 참조의 대표적인 쓰임은 컴파일러로 하여금 컴파일 시간에 어떤 인자로 좌측값이 오는지 우측값이 오는지에 따라 오버로딩을 할 수 있도록 도와주는 것이다.
기본적으로 int p = 1;을 수행하면 값 1은 p에 복사되고 1에 필요한 메모리는 없어진다.
반면 int &&p = 1;을 수행하면 값 1에 필요한 메모리는 사라지지 않고 이 메모리를 p는 가리키게 된다. 
마치 1에 temp라는 별명을 쥐어주고 temp를 가리키는 것과 같다.
int temp = 1; int &p = temp; 이 코드와 비슷한 효과를 낸다. (물론 우측값 참조는 int temp = 1; 이러한 과정이 없으므로 더 빠르다.)
int &a = b + c -> 불가능
int &&a = b + c -> 가능, 속도 빠름
int a = b + c -> 가능, 속도 느림
우측값 참조로 된 a는 b + c 의 결과가 반영된 임시객체를 가리키게 된다.
속도가 빨라지는 이유는 int a = b + c 이 경우 b + c 결과가 a에 복사된다.
연산 순서는 b + c 연산 후 객체 생성 -> b + c 객체를 a로 복사 -> b + c 객체 파괴 이렇게 3번의 연산이 이루어진다. 
반면 int &&a = b + c 의 연산 순서를 보면 b + c 연산 후 객체 생성 -> a는 b + c 객체를 참조 이렇게 복사가 이루어지는 곳이 없이 순조롭게 연산이 끝난다.
간단히 &&는 우측값의 생명 주기를 연장해준다고 생각하면 된다.

class Mover
{
	int m_var;
public:
	void func(int a) { m_var = a; }
	void func(int& a) { m_var = a; }
	void func(const int& a) { m_var = a; }
	void func(int&& a) { m_var = a; }
};
위와 같은 클래스에서 4가지 func를 비교해보겠다.

1. void func(int a) { m_var = a; }
함수 인자를 받을 때 a로 값이 복사되어 한 번 복사가 발생되고 m_var에 a 값을 옮기는 과정에서 복사 한 번이 더 발생한다.
총 복사: 2번

2. void func(int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
인자로 좌측값만 받을 수 있다.
총 복사: 1번

3. void func(const int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다. (a는 const로 변경불가 할 뿐 참조로 받은 것이다.)
인자로 우측값과 좌측값 모두 받을 수 있다.
총 복사: 1번

4. void func(int&& a) { m_var = a; }
여기서 주의할 것은 int&& a에서 a는 좌측값이다. (a라는 별명, 즉 실체가 있을 때는 좌측값으로 취급된다.)
좌측값 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
총 복사: 1번

2, 3, 4번은 모두 복사가 1번 이루어지는데 사용하는 이유가 있다.
2번은 좌측값만 취급하기에 func(1) 과 같은 것을 다루지 못한다.
3번은 func(1), func(p) 좌측, 우측값을 모두 다루지만 함수 내부에서 값 변경을 할 수 없다.
4번은 func(1), func(1+2) 등 우측값을 다룰 수 있고 내부에서 함수 인자를 바꿀 수도 있다. (밑의 함수 처럼 말이다.)
void func(int&& a) { a = 3; m_var = a; } -> func(100)을 해도 m_var = 3이다.
보통 함수 인자 넘길 때 복사가 발생하지 않게 하기 위해서는 밑과 같이 우측값 참조자를 사용한 것과 그냥 참조자를 사용한 것 두 가지를 모두 정의한다. (이러면 좌측값, 우측값이 모두 의도한 데로 커버된다.)
void func(int&& a) { m_var = a; }; void func(int& a) { m_var = a; }

우측값 참조를 효율적으로 이용하기 위한 move()

template <typename T>
void swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}
해당 함수를 보면 복사가 3번 발생한다.
생성자가 복사 생성자라 복사 발생 -> 1
a = b에서 복사 발생 -> 2
b = tmp에서 복사 발생 -> 3
복사가 총 3번 발생하는데 자료형 T의 크기가 크면 클수록 속도가 많이 느려질 것이다.

template <typename T>
void swap(T &a, T &b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}
복사가 발생하는 구간이 없이 모두 이동 생성이다.
복사 생성보다는 이동 생성이 빠르고 좌측값을 우측값으로 바꾸어 이동 생성을 가능하게 하는 것이 바로 move() 함수이다.
물론 이렇게 이동 생성으로 득을 보려면 자료형 T에 T& T::operator=(T&& s) 이러한 대입 연산자 오버로딩을 따로 만들어 줘야 한다.
중요한 것은 = 연산자에 의해서 이동이 발생한는 것이지 move() 함수에서 이동이 발생하는 것이 아니라는 것이다.

move() 예시를 좀 더 들어보면 우측값 참조는 우측값 + 참조이다.
void func(int&& a) { a = 3; }
int q = 3;
int &p = q;
func(move(p));
여기서 q, p의 값은 모두 3이다. 우측값으로 넘겨주었지만 참조라 값이 변한 것이 원본에 영향을 미친다.

int q = 1;
func(move(q));
이것도 마찬가지로 q의 값은 3이다. 우측값으로 넘겼지만 참조라 q의 값이 func() 함수 때문에 변한다.

- move() 주의점
void func(int &&a)
{
	int b = a; // a는 우측값으로 받았지만 이름이 있기에 다시 좌측값으로 치기에 복사가 발생함
	int c = move(a); // a는 move()로 인해 우측값이 되어 이동 연산이 가능해진다.
}
함수를 짜는 경우에 위와 같은 경우를 잘 생각해야 한다.

class A {};
void func(A& a) {}
void func(A&& a) {}
이러한 코드에서 func(A())는 void func(A&& a) {}가 호출된다. A()는 생성자로 임시 생성된 임시객체이기 때문에 우측값이다.

- 보편적(템플릿) 참조
void func(int&& a) {}
위와 같은 함수가 있다고 하자
func(1) -> 우측값이라 가능하다.
func(A) -> A라는 변수는 좌측값이라 불가능하다.
그렇다면 func(A)이러한 짓을 위해 void func(int& a) {}라는 함수를 추가적으로 더 만들어줘야 한다.
여간 귀찮은 일이다.

하지만 템플릿 프로그래밍을 사용하면 이 귀찮은 짓을 덜 수가 있다.
template <class T>
void func(T&& a) { /* 어떤 행동 */ }
이러한 함수가 있다면 func(1), func(A) 모두 커버가 가능하다. 굳이 추가적으로 T&, const T&에 대한 함수를 따로 작성하지 않아도 된다.

- forward 형변환 (사실은 forward는 함수)
template <class T>
void subfunc(T&& p) {  }

template <class T>
void func(T&& a) { subfunc(a); }
이러한 두 함수가 존재한다고 하면 func에서 호출하는 subfunc(a)에서 문제가 발생하는데 func() 내부에서 사용되는 a는 우측값 참조로 받았지만 이름이 있는 상태이기에 좌측값으로 취급이 된다.
그러면 subfunc() 함수는 T& a를 가정하고 참조 a를 받는 함수로만 컴파일러가 취급한다.
이를 해결하기 위해 forward 형변환이 필요하다. 밑과 같이 작성한 func() 함수는 이러한 문제를 해결한다.
template <class T>
void func(T&& a) { subfunc(forward<T>(a)); }
이렇게 작성하면 func() 내부에서는 우측값이면 subfunc(move(a))로 수행되고 좌측값이면 subfunc(a)로 수행된다.

자동으로 메모리 해제해주는 스마트 포인터가 있다.

- 스마트 포인터 unique_ptr
소유권은 유일해야 한다. 즉 객체를 가리키는 포인터는 무조건 하나여야 한다.
unique_ptr<int> A(new int(1));
unique_ptr<int> A = make_unique<int>(1);
위와 같이 사용하면 되고 실제 값을 얻거나 포인터 위치를 참조할 때는 기존 포인터와 동일하게 *A, A(또는 A.get()) 이렇게 사용한다.
메모리 해제는 별 신경을 쓸 필요가 없다. 블록을 벗어나던 아니던 포인터가 쓰이지 않는다고 판단되면 알아서 해제한다.
스마트 포인터라고 해서 포인터를 함수에 넘기거나 하는 경우 더 특별한 것은 없다.
unique_ptr<int> A(new int(1));
void func(int* ptr) {}
이렇게 한 뒤에 func(A); 하면 된다. 기존의 포인터를 인자로 받는 함수와 같다.
unique_ptr은 말 그대로 유니크하기 함부로 = 로 포인터를 더 연결할 수 없다.

밑의 예시를 보면
unique_ptr<int> A(new int(1)), B;
B = A; // 안된다. A의 값을 가리키는 포인터는 A 뿐이여야 한다.
B = move(A); // 된다. 하지만 기존 A는 껍데기가 된다.
A의 주소를 보면 00000000으로 나오고 기존의 A의 주소가 B의 주소가 된 것을 알 수 있다.

예시 한 가지 더!
vector<std::unique_ptr<A>> vec;
unique_ptr<A> pa(new A(1));
vec.push_back(pa); // 될까? 안된다. unique_ptr의 소유권은 유일해야 한다.
vec.push_back(std::move(pa)); // 잘 된다. 단지 기존의 pa가 껍데기가 될 뿐...
vec.emplace_back(new A(1)); // 중간 다리 없이 하고 싶다면 emplace_back을 사용해도 된다.

class A
{
public:
	A(int a){};
	A(const A& a) = delete;
};
여기서 A(const A& a) = delete; 이러한 표현이 가능한데 = delete를 하게 되면 A의 생성자를 명시적으로 사용하지 않겠다는 것이다. 
따라서 A temp(1); 이러한 표현은 불가능하다는 것이고 보통 객체가 하나여야 하는 싱글턴 패턴에서 자주 사용한다.

기존의 동적 할당과 비교하면 밑과 같이 다르다.

class A {
	int p;
public:
	A() { p = 1; }
	A(int k) { p = k; cout << "생성됨\n"; }
	~A() { cout << "해제됨\n"; }
};

// 기존의 방식
vector<A*> pAry;
for (int i = 0; i < 10; i++)
{
	A* ptr = new A();
	pAry.push_back(ptr);
}
cout << "소멸 호출\n";
while (!pAry.empty()) {
	delete pAry.back();
	pAry.pop_back();
}
일일이 해제해야 한다.

// unique_ptr을 사용한 방식
vector<unique_ptr<A>> pAry;
for (int i = 0; i < 10; i++)
{
	unique_ptr<A> ptr = make_unique<A>();
	pAry.push_back(move(ptr));
}
cout << "소멸 호출\n";
따로 할당 해제에 대한 코드를 넣을 필요가 없다.

- 스마트 포인터 shared_ptr
포인터에 대한 소유권이 유일하지 않아도 된다.
따라서 unique_ptr과 다르게 객체를 몇 개의 포인터가 가리키는지 알 수 있는 참조횟수가 도입되는데 이 참조횟수를 기록하는 객체에 대한 공간이 따로 할당된다.
shared_ptr<int> A(new int(1)), B;
B = A; // 가능하다.
위의 경우 B, A는 모두 같은 곳을 가리키게 된다.

밑의 경우가 특이한데
std::vector<std::shared_ptr<int>> vec;
vec.push_back(std::shared_ptr<int>(new int(1)));
vec.push_back(std::shared_ptr<int>(vec[0]));
vec.push_back(std::shared_ptr<int>(vec[1]));
이러한 경우 vec[0], vec[1], vec[2] 이 세개의 포인터는 모두 같은 곳을 가리키게 된다.
이러한 시점에서 vec.erase(vec.begin());을 몇번 수행해야 이 포인터가 할당 해제가 될까?
3번해야 할당된 shared_ptr이 해제가 된다. 위의 경우 참조 횟수는 3번이 된다.
shared_ptr은 자신의 참조 횟수가 0이 되는 순간 해제하는 특징이 있다.

shared_ptr의 참조횟수는 use_count()라는 함수로 알 수 있다.
shared_ptr<int> A(new int(1));
A.use_count(); // 이런 식으로 사용한다.
여기서 A의 참조 횟수는 1이다.

shared_ptr 생성방식도 unique_ptr과 거의 비슷한데 한가지 주의사항이 있다.
std::shared_ptr<int> p1(new int(1));
얘는 int 값 1을 가진 녀석을 동적할당한다.
그 후에 shared_ptr 포인터로 동적할당한 녀석을 가리키면서 shared_ptr의 참조횟수를 담고있는 객체를 동적할당한다.
일단 여기서 값비싼 연산인 동적할당 2번이 발생한다.
std::shared_ptr<int> p1 = std::make_shared<int>(1);
얘는 그와 다르게 shared_ptr의 참조횟수를 담고있는 객체와 int 값 1을 가진 녀석을 한방에 동적할당하여 연산이 더 적다.
그니까 바람직하게 std::make_shared<int>(); 이 녀석을 사용하도록 하자.

int* p = new int(1);
shared_ptr<int> pA(p);
shared_ptr<int> pB(p);
위 예시를 보면 pA와 pB의 참조횟수를 담고있는 객체는 다르다.
따라서 pA.use_count()와 pB.use_count()는 모두 1이다.
따라서 pA와 pB 중 하나라도 참조횟수가 0이 된다면 1을 담고있던 값을 가리키턴 포인터 p는 할당 해제될 것이다.
이때 오류가 발생하는데 만약 pA의 참조횟수가 0이 되어 p를 해제하게 된다면 pB의 참조횟수는 아직 1이라 pB가 가리키는 포인터는 아직 해제가 안된줄 알고 있게 된다.
이는 모순적인 상황이고 결과적으로 p에 대한 소멸자가 두번 호출되게 되어 컴파일러는 에러를 출력하게 된다.

int* p = new int(1);
shared_ptr<int> pA = shared_ptr<int>(p); // 또는 비효율적이게 shared_ptr<int> pA(p);
shared_ptr<int> pB = shared_ptr<int>(pA); // 여기서 shared_ptr<int> pB = shared_ptr<int>(p);는 오류이다. 이미 p에 대해 생성된 공유 포인터를 다시 생성할 수는 없다.
반면 위와 같이 shared_ptr<int> 객체를 새로 생성하는 것이 아니라 shared_ptr<int>가 가리키는 포인터를 직접 가져다 주면 해결된다.
이때 참조횟수를 담고있는 객체를 pA와 pB가 모두 공유하게 되고 pA.use_count()와 pB.use_count()는 모두 2이다.

위의 예시도 약간의 문제가 있는데 원본 포인터 p를 이용하여 p에 대해 생성된 공유 포인터를 바로 알 수가 없다는 것이다.
따라서 클래스를 사용한다면 밑과 같이 enable_shared_from_this</* 클래스 */> 를 상속하는 것이 좋다.
class A : public std::enable_shared_from_this<A> {
	int p;
public:
	A() { p = 1; }
	A(int k) { p = k; }
};

A* p = new A(1);
shared_ptr<A> pA = shared_ptr<A>(p); // 여기서 shared_ptr<A> pA = p->shared_from_this(); 이렇게 해버리면 오류다. 아직 p에 대한 공유 포인터가 정의되지도 않았기 때문이다.
shared_ptr<A> pB = p->shared_from_this();
enable_shared_from_this 이 녀석을 상속하면 shared_from_this()라는 함수가 따라오는데 얘가 객체의 shared_ptr을 가져온다.
명심할 점은 shared_from_this()는 shared_ptr이 정의된 객체에서만 사용해야 한다는 것이다.

shared_ptr을 사용할 때 블록 범위를 잘 고려해야 한다. 특정 블록에서 정의된 shared_ptr은 그 블록 안에서만 참조를 하게 되고 벗어나는 순간 참조 횟수 1개를 깎는다.
shared_ptr<int> pA;	
if (true) {
	shared_ptr<int> pB = make_shared<int>(1);
	pA = pB;
	// 이 순간의 pA의 참조 횟수는 2이다.
}
// 이 순간의 pA의 참조 횟수는 1이다. pB는 더 이상 없기 때문이다.


shared_ptr는 문제점이 있는데 바로 순환 참조이다.
다음 예시로 알 수 있다. 한 명의 사람은 어떤 모임에 속하게 될 것이고 어떤 모임은 여러 명의 사람을 담고 있을 것이다.
-----------------------------------------------------------------------------------------------------
class User;

class Group
{
	vector<shared_ptr<User>> m_GroupList;
public:
	Group() { cout << "Group 생성됨.\n"; }
	~Group() { m_GroupList.clear(); cout << "Group 소멸됨.\n"; }
	void AddUser(shared_ptr<User> user) { m_GroupList.push_back(user); }
};

class User 
{
	shared_ptr <Group> m_Belong;
	int m_Num;
public:
	User(int i) { m_Num = i; cout << i << "번째 User 생성됨.\n"; }
	~User() { cout << m_Num << "번째 User 소멸됨.\n"; }
	void SetGroup(shared_ptr<Group> group) { m_Belong = group; }
};

int main()
{
	shared_ptr<Group> pGroup = make_shared<Group>();

	for (int i = 0; i < 10; i++) {
		shared_ptr<User> pUser = make_shared<User>(i);
		pGroup->AddUser(pUser);
		pUser->SetGroup(pGroup);
	}
}
-----------------------------------------------------------------------------------------------------
이 예시에서 for문 내에서 생성된 10개의 User 객체는 생성만 되고 소멸은 되지 못한다. 그를 담고있는 Group도 소멸되지 못한다.
Group 1개와 User 10개의 생성자만 호출될 뿐이다. 이는 순환 참조 문제 때문이다.
pGroup이 가진 vector 배열은 10개의 User 공유포인터를 가지고 각 공유포인터들은 동적 생성된 User를 가리킨다.
그러면 일단 i가 0인 경우만 분석해보자.
shared_ptr<User> pUser = make_shared<User>(i); 에서 i가 0인 경우 객체가 동적 생성되었고 이때 참조횟수가 1개 증가한다. 
이때 pGroup->AddUser(pUser); 하면서 m_GroupList[0]가 만들어지고 해당 공유 포인터의 참조횟수가 1개 증가하여 m_GroupList[0]의 참조횟수는 2가 된다.
그 다음 pUser->SetGroup(pGroup); 이 구문이 진행되면서 i가 0인 경우 동적 할당된 객체의 Group이 지정된다.
이 때 m_Belong은 pGroup을 가리키게 되고 pGroup 공유 포인터의 참조 횟수는 1개 증가된다. (i가 0일 때 pGroup 참조 횟수는 1개일 것이다.)
이렇게 m_GroupList[0]과 pGroup의 참조횟수가 서로 0 이상인 경우 이 둘을 갑자기 해제하는 상황을 생각해보자.
먼저 컴파일러는 공유 포인터 pGroup에 연결된 객체를 해제하려고 할 것이다. (엄격하게는 m_GroupList[0] 이 녀석에 연결된 녀석부터 해제하려 하겠지만 설명할 때 순서는 별 상관없다.)
해제하려고 보니 해당 객체에는 m_GroupList[0]이라는 공유 포인터가 있었고 해당 공유 포인터는 참조 횟수가 0 이상이라 해제할 수가 없는 상황이다.
이를 해제할 수가 없으니 pGroup은 해제가 되지 않고 m_GroupList[0] 이 녀석의 참조 횟수가 0이 되는 순간을 기다리게 된다.
그렇다면 m_GroupList[0] 이 녀석의 참조 횟수가 0이 되는 것이 가능할까? 불가능하다.
이유는 m_GroupList[0]가 가리키는 User 객체를 해체하려하면 User 객체의 공유 포인터 m_Belong이 pGroup을 가리키고 있어 참조 횟수가 1이라 이를 못하게 한다.
따라서 서로의 멤버 변수 공유 포인터의 참조 횟수가 0이 아니라 서로 동적 할당 해체를 하지 못하고 소멸자도 호출되지 못하는 것이다.
이는 shared_ptr의 고질적인 문제로 이를 해결하려면 weak_ptr이 필요하다.
그리고 예시에 보았듯이 unique_ptr과 다르게 shared_ptr을 인자로 받는 함수는 명확하게 shared_ptr이라고 밑 예시와 같이 명시해주어야 한다. (이는 weak_ptr도 마찬가지이다.)
void SetGroup(shared_ptr<Group> group) { m_Belong = group; }

- 스마트 포인터 weak_ptr
shared_ptr은 weak_ptr이 될 수 있다. (형변환이 된다.)
weak_ptr은 shared_ptr과 다르게 1을 초과하여 참조횟수를 늘리지 않는다.

shared_ptr<int> pA = make_shared<int>(1), pB, pC, pD;
pB = pC = pD = pA;
이 상태에서 pA의 참조 횟수는 4이다.

shared_ptr<int> pShare = make_shared<int>(1);
weak_ptr<int> pA = pShare, pB, pC, pD;
pB = pC = pD = pA;
반면 이 상태에서 pA의 참조 횟수는 1이다.
주의할 점은 weak_ptr<int> pA = make_shared<int>(1); 이렇게 사용해버리면 pA는 이상한 곳을 가리키게 된다. 따라서 실제 공유 포인터를 거친 후에 그 것을 이용해서 넘겨야 한다.
위의 경우에서 pA, pB, pC, pD 중 어느 하나라도 해제 되면 참조 횟수가 0이 되어버려 실제 할당된 객체가 해제되어버려 나머지 weak_ptr은 허상을 가리키고 있는 것이 되어버린다.
허상의 주소값을 호출하는 것을 방지하기 위해 weak_ptr의 주소를 실제로 알기위해서는 한 단계의 함수를 거쳐서 호출하게 되어있는데 그 것이 lock 함수이다.
위 코드 예시에서 pA의 실제 주소를 알려면 pA.lock() 이렇게 해야한다.
lock() 함수는 pA가 허상의 주소 즉, 이미 해제된 객체를 가리키고 있다면 false(nullptr)를 반환하고 아니라면 주소값에 해당하는 shared_ptr을 반환한다.

---------------------------------------------------------------------------------------
weak_ptr<int> pA, pB;
if (true) {
	shared_ptr<int> pShare = make_shared<int>(200);
	pB = pA = pShare;
	cout << (pA.lock() ? "포인터 값: " + to_string(*pA.lock()) : "포인터는 null 값") << "\n";
}
cout << (pA.lock() ? "포인터 값: " + to_string(*pA.lock()) : "포인터는 null 값") << "\n";
---------------------------------------------------------------------------------------
이 예시에서 출력 값은 다음과 같다.
---------------------------------------------------------------------------------------
포인터 값: 200
포인터는 null 값
---------------------------------------------------------------------------------------
pShare 포인터의 참조 횟수는 if문 안에서 1이지만 if문을 벗어나면 0이 된다.
따라서 if문 안에서는 weak_ptr인 pA는 공유 포인터인 pShare를 가리키고 실제 주소가 존재하니 pA.lock() 값이 nullptr이 아니라 실제 객체의 값이 출력된다.
if문 밖에서는 pShare이 해제되었으니 pA는 허상을 가리키게 되면서 pA.lock()에서 nullptr이 도출되고 이로 인해 포인터는 null 값이라는 결과가 출력된다.
pB = pA = pShare; 이 구문을 수행하는 시점에서도 pA, pB의 참조 횟수는 최대 1로 증가하지 않는다.

그렇다면 아까 shared_ptr로 짰던 Group과 User 클래스 예시를 weak_ptr로 짜보자.
-----------------------------------------------------------------------------------------------------
class User;

class Group
{
public:
	vector<weak_ptr<User>> m_GroupList;
public:
	Group() { cout << "Group 생성됨.\n"; }
	~Group() { m_GroupList.clear(); cout << "Group 소멸됨.\n"; }
	void AddUser(weak_ptr<User> user) { m_GroupList.push_back(user); }
	void PopUser() { m_GroupList.pop_back(); }
};

class User
{
public:
	weak_ptr <Group> m_Belong;
	int m_Num;
public:
	User(int i) { m_Num = i; cout << i << "번째 User 생성됨.\n"; }
	~User() { cout << m_Num << "번째 User 소멸됨.\n"; }
	void SetGroup(weak_ptr<Group> group) { m_Belong = group; }
};

int main()
{
	shared_ptr<Group> pGroup = make_shared<Group>();

	for (int i = 0; i < 10; i++) {
		shared_ptr<User> pUser = make_shared<User>(i);
		pGroup->AddUser(pUser);
		pUser->SetGroup(pGroup);
	}
}
-----------------------------------------------------------------------------------------------------
실행 후 출력을 보면 생성과 해제가 모두 잘 이루어지는 것을 알 수 있다.
i가 0인 경우부터 생각해보자.
공유 포인터인 pUser는 make_shared로 생성되고 참조 횟수가 1이 된다. 그 후에 AddUser를 수행하여 weak_ptr인 m_GroupList[0]의 참조횟수도 1이 된다.
그 후에 SetGroup() 함수로 인해 공유 포인터 pGroup을 weak_ptr인 m_Belong이 가리키게 된다. 당연히 pGroup은 공유 포인터라 참조횟수는 weak_ptr과 따로 돌기에 1에서 증가하지 않는다.
그 후 for문의 블록이 다시 돌아가기에 공유 포인터 pUser가 해제되면서 pUser와 연결되어있던 m_GroupList[0]은 허상의 공간을 가리키게 된다.
이러한 루틴이 for문에서 10번 반복되고 맨 마지막에 공유 포인터 pGroup이 해제되면서 이에 연결되어 있던 weak_ptr인 m_Belong들은 허상의 공간을 가리키게 된다.
이렇게 weak_ptr은 허상을 가리킬 수 있는 위험성이 있기에 lock()이라는 중간 다리를 건너야 한다.
중간 다리를 건너는 과정으로 인해 오버헤드가 발생하기에 왠만하면 weak_ptr말고 shared_ptr, unique_ptr을 사용해야 한다.
결과적으로 weak_ptr은 shared_ptr을 가리키는 일종의 임시 포인터라고 생각하면 된다.
shared_ptr가 어떤 상태이던지 weak_ptr은 그냥 가리킬 뿐이다.

- Callable (function 자료형)
()를 붙여서 호출 가능한 것을 C++에서는 Callable이라고 한다. (전에 보았던 Funtor와 비슷하다.)
class CallClass {
public:
	void operator()(int a, int b) { std::cout << "a + b = " << a + b << std::endl; }
};
위와 같이 생긴 녀석이 바로 Callable이다.
이유는 CallClass obj; obj(1, 2);와 같은 코드가 가능하기 때문이다.
auto CallFunc = [](int a, int b) { std::cout << "a + b = " << a + b << std::endl; }; 이 녀석도 Callable이다.
왜냐면 CallFunc(1, 2);이렇게 ()를 붙여서 호출이 가능하기 때문이다.
이러한 Callable을 객체 형태로 보관가능하게 해주는 것이 std::function이다.

간단한 사용법은 다음 예시를 보면 이해하기 쉽다.
-------------------------------------------------------------------------------------------------------------
void CallFunc(int a, int b) {
	cout << "a + b = " << a + b << endl;
}

class CallClass {
public:
	CallClass() {}
	void operator()(int a, int b) { cout << "a + b = " << a + b << endl; }
	int MemberFunc_1(const CallClass& var) { return 1; }
	void MemberFunc_2(int p) const { cout << "this is const function\n"; }
	short MemberFunc_3() { return 1; }
};

int main()
{
	function<void(int, int)> A = CallFunc;
	A(1, 2);

	function<void(int, int)> B = CallClass();
	B(3, 4);

	function<int(string&&)> C = [](string&& str)->int {cout << str << endl; return 1; };
	cout << C("Modern C++ Study") << "\n";

	CallClass tempClass;
	function<int(CallClass&, const CallClass&)> D = &CallClass::MemberFunc_1;
	D(tempClass, CallClass());

	function<void(const CallClass&, int)> E = &CallClass::MemberFunc_2;
	E(tempClass, 1);

	function<short(CallClass&)> F = &CallClass::MemberFunc_3;
	F(tempClass);
}
-------------------------------------------------------------------------------------------------------------
보통의 함수나 Functor는 { function<반환형(함수 인자들)> 함수객체이름 = 함수 or Functor or 람다 }와 같이 사용하면 된다.
멤버 함수는 { function<멤버 함수 반환형(멤버 함수를 가지고 있는 특정 객체 참조, 멤버 함수 인자들)> 함수객체이름 = 멤버 함수의 주소 }
클래스의 멤버 함수는 약간 다르게 돌아가는데 함수 인자들 외에 해당 객체의 참조를 인자로 받아야 한다.
그리고 해당 클래스 멤버 함수에 대한 주소를 받아야 하기에 &가 추가적으로 붙게 된다.

- bind 함수
함수 인자 중 하나를 정해주는 bind 함수가 존재한다.
placeholders라는 함수 인자 위치가 존재하는데 이를 이용하면 해당 인자 위치에는 함수 값을 넣을 수 있게 된다.

밑은 사용 예시다.
int add(int v, int w, int x, int y, int z) { return v + w + x + y + z; }
auto add_binded = std::bind(add, std::placeholders::_1, 7, std::placeholders::_2, 7, 7);
이경우 add_binded 함수는 add(사용자 지정 값, 7, 사용자 지정 값, 7, 7); 으로 인식되고 사용자 지정 값을 추려준다.
따라서 add_binded(0,1)은 0 + 7 + 1 + 7 + 7 이 되어 22라는 값이 도출된다.
이렇게 std::placeholders::는 사용자 지정 값을 넣을 수 있는 공간을 만들어주는 역할을 해주고 20번째까지 존재한다.

bind에 지정해주는 값은 복사되어서 전달되기에 참조를 사용하는 경우는 참조 인자라고 명시해주어야 한다. 밑은 이에 대한 예시이다.
void Swap(int& a, int& b) 
{ 
	int t = move(a); 
	a = move(b);
	b = move(t);
}
int a = 3, b = 7;
auto Swap_binded = std::bind(Swap, a, b); swap_binded();
위와 같은 상황에서 a와 b는 과연 바뀌었을까? 안바뀐다. bind에 전달된 값은 복사되어 들어가기 때문이다.
이렇게 auto Swap_binded = std::bind(Swap, std::ref(a), std::ref(b)); 참조라고 명시를 하면 바뀐다.

template <class T>
void Swap(T& a, T& b)
{ 
	T t = move(a);
	a = move(b);
	b = move(t);
}
auto Swap_binded = std::bind(Swap<int>, std::ref(a), std::ref(b));
만약 Swap함수가 위과 같은 템플릿 함수라면 그 형을 당연히 명시해주어야 한다.
그런데 이 템플릿 Swap 함수가 클래스 멤버 함수라면? function 자료형을 다루었던 방식을 생각해보면 된다.
class CSwap
{
public:
	template <class T>
	void Swap(T& a, T& b)
	{
		T t = move(a);
		a = move(b);
		b = move(t);
	}
};
CSwap swapClass;
auto Swap_binded = std::bind(&CSwap::Swap<int>, std::ref(swapClass), std::ref(a), std::ref(b));
Swap_binded();
이렇게 특정 클래스 객체를 따로 집어 넣어주면 된다.
그리고 const &인 경우는 std::cref()를 사용한다.

- 유니폼 초기화
class A {
 public:
  A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
  A a();
}
위 상황에서 "A 의 생성자 호출!" 이라는 문구가 과연 콘솔 창에 나올까? 안나온다.
a()는 컴파일러가 보기에 functor처럼 인식을 하여 생성자를 호출할 생각조차 하지 않는다.
그렇다면 A a{};는 어떨까? "A 의 생성자 호출!"가 콘솔 창에 출력이 된다.
{}를 사용하여 초기화하는 것을 균일한 초기화라고 한다.
균일한 초기화는 형이 조금이라도 다르면 명시적 형변환을 해주어야 한다.
A(int x) {}; A a(3.5); 이건 가능하지만 A a{3.5}; 이건 안된다. 물론 A a{(int)3.5}; 이건 가능하다.
명시적 형변환을 통해 아래와 같은 문구들이 편하게 사용가능하다.
std::map<std::string, int> var_map = { {"abc", 1}, {"hi", 3}, {"hello", 5}, {"c++", 2}, {"java", 6} };
std:vector<int> var_vec = { 1, 2, 3, 4, 5 };

- C++ 쓰레드
C++에서는 thread라는 자료형을 통해 쓰레딩을 사용한다.

단순한 예시를 들어보자
void func(int &p) { p++; return p; }
이러한 함수를 쓰레딩으로 돌리기 위해선 std::thread th_for_func = thread(func, std::ref(i)); 이렇게 사용한다.
아니면 std::thread th_for_func(func, std::ref(i)); 이렇게 생성자로 넣어준다.
std::bind 함수와 인자가 유사하다.
쓰레드를 생성하고 난 뒤에는 join() 함수를 통해 수행하게 된다. 위의 경우에서는 th_for_func.join() 이렇게 사용한다.
join()은 해당 쓰레드가 모두 끝나는 경우 return 된다.
join()과 다른 성격을 가진 녀석도 있는데 detach() 함수이다.
join()을 하면 어떤 프로그램이 수행되는 시간 내에 무조건 join()한 함수가 종료된다. (반대로 join()한 함수가 종료되지 않았다면 프로그램도 계속 돌아간다.)
detach()를 하면 프로그램의 동작이 끝났어도 백그라운드로 해당 함수들이 수행된다.
간단하게 main 함수가 동작을 중단해도 detach()로 수행한 쓰레드들은 알아서 동작한다.
thread에게 전달하는 함수의 반환값은 추후에 알 방법이 없기 때문에 특정 함수를 수행하고 난 뒤에 어떤 결과값을 받고 싶다면 void 형 함수의 인자에 포인터나 참조로 넘겨야 한다.

밑은 쓰레딩 연산 속도를 비교하기 위한 예제 코드다.
------------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

const int destin = 2100000000;
double result;
clock_t Start, End;

void func(int& s)
{
	for (int i = 0; i < destin; i++)
		s++;
}

void th_func(int& s) {
	int sum = 0;
	for (int i = 0; i < destin / 3; i++)
		sum++;
	s += sum;
}

int func_ret(int p) {
	return p;
}

int main()
{
	int sum = 0;
	Start = clock();
	func(sum);
	End = clock();
	result = (double)(End - Start) / 1e3;
	cout << "Sum Result : " << sum << '\n';
	cout << "Normal Func Time : " << result << "\n\n";

	sum -= destin;

	Start = clock();
	std::thread th_1 = thread(th_func, std::ref(sum));
	std::thread th_2 = thread(th_func, std::ref(sum));
	std::thread th_3(th_func, std::ref(sum));
	th_1.join();
	th_2.join();
	th_3.join();
	End = clock();
	result = (double)(End - Start) / 1e3;
	cout << "Sum Result : " << sum << '\n';
	cout << "Thread Func Time : " << result << '\n';
}
------------------------------------------------------------------------------------------------
위를 실행해보면 결과는 다음과 같다.
----------------------------
Sum Result : 2100000000
Normal Func Time : 1.414

Sum Result : 2100000000
Thread Func Time : 0.45
----------------------------
거의 3배 이상 속도 차이가 나는 것을 알 수 있다.

위의 예시는 쓰레드들이 같은 원소를 참조하여 발생하는 문제를 고려하지 않았다.
th_func에서는 int sum이라는 변수를 따로 두어서 여기에 더한 뒤에 최종 값은 s에 추가적으로 더해주는 것이기에 여기선 이러한 문제가 발생하지 않는다.
하지만 밑과 같이 구현된다면 어떻게 될까?
void th_func(int& s) {
	for (int i = 0; i < destin / 3; i++)
		s++;
}
이렇게 구현이 되면 문제가 발생한다.
각 쓰레드마다 공통된 변수 s를 동시에 접근해서 같이 더하면 한쪽은 더해지고 나머지 한쪽은 더해지지 않는 경우가 발생하기 때문이다.
이렇게 각기 다른 쓰레드가 같은 자원을 동시에 접근하는 것을 방지하기 위해 C++에 std::mutex가 존재한다.

먼저 임계구역 교통정리를 해주는 mutex를 선언한다.
그냥 변수 선언하듯이 std::mutex var; 이렇게 해주면 된다.
다른 쓰레드들이 건드리지 못하게 할 때는 lock()으로 잠금하고 다른 쓰레드들의 접근을 허용할 때는 unlock()을 사용하면 된다.
그렇다면 th_func를 mutex를 활용하여 제대로 바꾸려면 어떻게 해야할까?
void func_improved(int& s, std::mutex& mvar)
{
	mvar.lock();
	for (int i = 0; i < destin / 3; i++)
		s++;
	mvar.unlock();
}
이렇게 바꾸면 될까?
이렇게 바꾼다면 한개의 쓰레드가 for문을 돌리는 동안 공유 자원이 잠겨 다른 쓰레드들은 그냥 지켜만 봐야한다.
제대로 바꾼 함수는 다음과 같아야 한다.
void func_improved(int& s, std::mutex& mvar)
{
	mvar.lock();
	for (int i = 0; i < destin / 3; i++)
		s++;
	mvar.unlock();
}
꼭 unlock()을 해주어야 한다는 점이 프로그래머에게 위험할 수 있다.
따라서 다음과 같은 std::lock_guard<std::mutex> lock()이 등장했다.
블록 내에서 선언된 다음과 같은 임계구역 잠금 변수는 선언시에 lock()을 걸며 블록을 빠져나오면서 자동으로 unlock()을 해준다.
바꾼 함수는 다음과 같다.
void func_improved(int& s, std::mutex& mvar)
{
	for (int i = 0; i < destin / 3; i++) {
		std::lock_guard<std::mutex> lock(mvar);
		s++; 
	}
}
mutex에는 데드락을 방지하기 위해 try_lock()이라는 함수도 제공한다. 해당 mutex의 lock()을 일단 시도하고 lock()이 성공한다면 true를 반환하고 실패한다면 false를 반환한다.
밑과 같이 보통 쓰인다.
void func_1(std::mutex& m1, std::mutex& m2) {
  for (int i = 0; i < 10; i++) {
    m1.lock();
    m2.lock();

	// 어떤 작업

    m2.unlock();
    m1.unlock();
  }
}

void func_2(std::mutex& m1, std::mutex& m2) {
  for (int i = 0; i < 10; i++) {
    while (true) {
      m2.lock();

      if (!m1.try_lock()) {
        m2.unlock();
        continue;
      }

      // 어떤 작업
	  
      m1.unlock();
      m2.unlock();
      break;
    }
  }
}
func_1은 보통의 방식대로 lock(), unlock()만 해주지만 func_2는 같은 방식으로 구현했다가 데드락이 걸려버릴 것이다.
따라서 func_2는 m1과 m2가 모두 lock()될 수 있는 상황을 만날 때 까지 계속 기다리도록 구현해야 한다.

##################### 쓰레드 더 진행해야 함 #####################

##################### 쓰레드 더 진행해야 함 #####################

- <random> 라이브러리
c의 난수 생성보다 효과적으로, 즉 더 랜덤하게 난수를 생성해주는 random 라이브러리가 c++에 있다. (따라서 기존 rand() 방식은 c++에서는 버리자!)
예시는 밑과 같다.
#include <iostream>
#include <random>

int main() {
  // 시드값을 얻기 위한 random_device 생성.
  std::random_device rd;

  // random_device 를 통해 난수 생성 엔진을 초기화 한다.
  std::mt19937 gen(rd());

  // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의.
  std::uniform_int_distribution<int> dis(0, 99);

  for (int i = 0; i < 5; i++) {
    std::cout << "난수 : " << dis(gen) << std::endl;
  }
}
사용법은 예시를 보면 알겠지만 난수 기기를 생성 -> 기기를 이용해 난수 엔진 초기화 -> 균등 분포 정의 -> 난수 획득 순서로 이어진다.
실제 컴퓨터 신호에 따른 난수를 생성해내는 것이기에 rand()와 같은 의사 난수 방식보다는 속도가 느리다.
mt19937라는 자료형은 난수 생성 엔진으로 메르센 트위스터라는 알고리즘을 이용한다고 한다...(이 보다 난수의 질은 좀 떨어지지만 메모리를 덜 먹는 minstd_rand 엔진도 있다.)
보통은 그냥 mt19937를 사용하는 엔진을 만들어 쓰는 것이 편하다.
std::mt19937 gen(rd()); 여기서 rd() 대신에 특정 시드값을 std::mt19937 gen(1234); 이렇게 박아 넣어도 된다.