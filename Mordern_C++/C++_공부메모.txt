explicit
암시적 변환 금지 시킴, 암시적 복사 생성자 호출 금지
예시) 
long p = 3;
char K = p; 이건 가능하지만 만약에서 long 형 변환에 explicit이 붙어있다면 컴파일러는 에러를 내뿜는다.
char K = long(p); 이렇게 해야 에러 없이 진행 가능하다.
즉 모든 것을 명시적으로 하게 만드려면 함수나 생성자 앞에 explicit을 붙이면 된다.

mutable
밑과 같은 클래스 const 함수는 클래스 내의 멤버 변수를 바꿀 수 없다.
void DoSomething(int x) const { }
하지만 클래스 내의 멤버 변수가 mutable int a; 이렇게 mutable이 붙어 선언이 되었다면 클래스 const 함수 내에서 멤버 변수를 바꿀 수 있다.
이런 애를 쓰는 이유는 이 함수를 사용하는 인터페이스로 보아서는 const가 붙어야 하는데 내부적으로 클래스 멤버 변수를 변경해야 하는 함수면 이를 사용한다.

형변환
static_cast<int>(float_variable); <=> (int)(float_variable)

dyanmic_cast
상속 관계에 있는 두 포인터 간에 캐스팅을 해줌 (static_cast<> 와 다르게 오류 찾기 쉬워서 씀)

보통 함수 호출보다 virtual이 붙은 함수 호출하는 시간이 더 오래걸린다.
클래스 포인터 다룰 때 항상 더 큰 녀석(자식)을 더 작은 녀석(부모)에게 줄 수 있다는 것을 인지하자 (그 반대는 안된다.)
다이아몬드 상속 문제(다중 상속에서 발생하는 문제)를 해결하는 virtual 상속에 대해 기억하기!

탬풀릿 사용시에는 template <class T>보다는 template <typename T> 이용하기

함수는 아니지만 함수인 척을 하는 녀석 Funtor
예시)
struct Comp {
  bool operator()(int a, int b) { return a > b; }
};
Comp compare;
int a = 3, b = 1;
cout << compare(a, b);
이런 짓이 가능해서 템플릿 프로그래밍에서 비교연산자 재정의해서 쓰기보다 이러한 Funtor를 넘겨 오름차순, 내림차순을 바꾸게 된다.

템플릿 template <typename T, int num = 5> 이런 문법 가능

대표적인 쓰임새 예시)

template <typename T>
struct Compare {
  bool operator()(const T& a, const T& b) const { return a < b; }
};

template <typename T, typename Comp = Compare<T>>
T Min(T a, T b) {
  Comp comp;
  if (comp(a, b)) {
    return a;
  }
  return b;
}

템플릿 함수를 작성할 때 그 순서에 유의할 것.

#define SIZE 10 // C-style
constexpr int size = 10; // modern C++

C++17의 Fold 기법

템플릿 메타 프로그래밍에서 들어가는 인수는 상수여야 한다.

밑과 같은 경우가 템플릿 메타 프로그래밍인데 여기서 함수 인자와 같이 들어가게 되는 N은 무조건 const 형과 같은 상수여야 한다.
template <int N>
struct Factorial {
	static const int result = N * Factorial<N - 1>::result;
};

template <>
struct Factorial<1> {
	static const int result = 1;
};

Factorial<k>::result
여기서 k는 상수가 아니면 에러다. 템플릿 메타 프로그래밍은 무조건 컴파일 시간에 결정될 수 있는 것만 가능하다.

typedef vector<int> VecInt;
using VecInt = vector<int>;

typedef void (*func)(int, int);
using func = void (*)(int, int);

함수 객체(Funtor)에는 절대로 특정 상태를 저장해서 이에 따라 결과가 달라지는 루틴을 짜면 안된다.
이는 C++ 컴파일러마다 STL 인터페이스는 같지만 구현 방식이 천차만별이기 때문이다.

람다 활용성
vec.erase(std::remove_if(vec.begin(), vec.end(), [](int i) -> bool { return i % 2 == 1; })
위와 같이 "벡터에서 홀수인 원소 지우기"를 수행하는 코드를 간결하게 작성가능하다.

lvalue(좌측값) rvalue(우측값)에 대한 정의
좌측값 = 대입 시에 왼쪽 혹은 오른쪽에 오는 식, ex) int p; int a = p; -> a, p 모두 좌측값
추가적으로 좌측값은 어떠한 메모리 위치를 가리키고 있는 값이라고도 볼 수 있다.
우측값 = 대입 시에 오직 오른쪽에만 오는 식, ex) int a = 3; -> 여기서 3이 우측값 / int q, p; int a = p * q; -> 여기서 p * q 는 우측값
int func() { int a = 1; return a; } -> 여기서 func()는 우측값이다. 왜냐하면 func() = 3; 이건 불가능하기 때문

&는 좌측값 참조다.
잘 알다싶이 다음 예시와 같이 보통 쓰임
void StringFunc(string &str) { str = "changed"; }
void StringFunc(const string &str) { cout << "str is const var" << endl; }

&&는 우측값 참조다.
int &b = 3; 이렇게 사용은 안되지만 int &&b = 3; 이런 표현은 가능하다.
int p = 1, q = 2; int &&b = p + q; 이런 임시 우측값을 담는 표현도 가능하다.
우측값 참조의 대표적인 쓰임은 컴파일러로 하여금 컴파일 시간에 어떤 인자로 좌측값이 오는지 우측값이 오는지에 따라 오버로딩을 할 수 있도록 도와주는 것이다.
기본적으로 int p = 1;을 수행하면 값 1은 p에 복사되고 1에 필요한 메모리는 없어진다.
반면 int &&p = 1;을 수행하면 값 1에 필요한 메모리는 사라지지 않고 이 메모리를 p는 가리키게 된다. 
마치 1에 temp라는 별명을 쥐어주고 temp를 가리키는 것과 같다.
int temp = 1; int &p = temp; 이 코드와 비슷한 효과를 낸다. (물론 우측값 참조는 int temp = 1; 이러한 과정이 없으므로 더 빠르다.)
int &a = b + c -> 불가능
int &&a = b + c -> 가능, 속도 빠름
int a = b + c -> 가능, 속도 느림
우측값 참조로 된 a는 b + c 의 결과가 반영된 임시객체를 가리키게 된다.
속도가 빨라지는 이유는 int a = b + c 이 경우 b + c 결과가 a에 복사된다.
연산 순서는 b + c 연산 후 객체 생성 -> b + c 객체를 a로 복사 -> b + c 객체 파괴 이렇게 3번의 연산이 이루어진다. 
반면 int &&a = b + c 의 연산 순서를 보면 b + c 연산 후 객체 생성 -> a는 b + c 객체를 참조 이렇게 복사가 이루어지는 곳이 없이 순조롭게 연산이 끝난다.
간단히 &&는 우측값의 생명 주기를 연장해준다고 생각하면 된다.

class Mover
{
	int m_var;
public:
	void func(int a) { m_var = a; }
	void func(int& a) { m_var = a; }
	void func(const int& a) { m_var = a; }
	void func(int&& a) { m_var = a; }
};
위와 같은 클래스에서 4가지 func를 비교해보겠다.

1. void func(int a) { m_var = a; }
함수 인자를 받을 때 a로 값이 복사되어 한 번 복사가 발생되고 m_var에 a 값을 옮기는 과정에서 복사 한 번이 더 발생한다.
총 복사: 2번

2. void func(int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
인자로 좌측값만 받을 수 있다.
총 복사: 1번

3. void func(const int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다. (a는 const로 변경불가 할 뿐 참조로 받은 것이다.)
인자로 우측값과 좌측값 모두 받을 수 있다.
총 복사: 1번

4. void func(int&& a) { m_var = a; }
여기서 주의할 것은 int&& a에서 a는 좌측값이다. (a라는 별명, 즉 실체가 있을 때는 좌측값으로 취급된다.)
좌측값 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
총 복사: 1번

2, 3, 4번은 모두 복사가 1번 이루어지는데 사용하는 이유가 있다.
2번은 좌측값만 취급하기에 func(1) 과 같은 것을 다루지 못한다.
3번은 func(1), func(p) 좌측, 우측값을 모두 다루지만 함수 내부에서 값 변경을 할 수 없다.
4번은 func(1), func(1+2) 등 우측값을 다룰 수 있고 내부에서 함수 인자를 바꿀 수도 있다. (밑의 함수 처럼 말이다.)
void func(int&& a) { a = 3; m_var = a; } -> func(100)을 해도 m_var = 3이다.
보통 함수 인자 넘길 때 복사가 발생하지 않게 하기 위해서는 밑과 같이 우측값 참조자를 사용한 것과 그냥 참조자를 사용한 것 두 가지를 모두 정의한다. (이러면 좌측값, 우측값이 모두 의도한 데로 커버된다.)
void func(int&& a) { m_var = a; }; void func(int& a) { m_var = a; }

우측값 참조를 효율적으로 이용하기 위한 move()

template <typename T>
void swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}
해당 함수를 보면 복사가 3번 발생한다.
생성자가 복사 생성자라 복사 발생 -> 1
a = b에서 복사 발생 -> 2
b = tmp에서 복사 발생 -> 3
복사가 총 3번 발생하는데 자료형 T의 크기가 크면 클수록 속도가 많이 느려질 것이다.

template <typename T>
void swap(T &a, T &b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}
복사가 발생하는 구간이 없이 모두 이동 생성이다.
복사 생성보다는 이동 생성이 빠르고 좌측값을 우측값으로 바꾸어 이동 생성을 가능하게 하는 것이 바로 move() 함수이다.
물론 이렇게 이동 생성으로 득을 보려면 자료형 T에 T& T::operator=(T&& s) 이러한 대입 연산자 오버로딩을 따로 만들어 줘야 한다.
중요한 것은 = 연산자에 의해서 이동이 발생한는 것이지 move() 함수에서 이동이 발생하는 것이 아니라는 것이다.

move() 예시를 좀 더 들어보면 우측값 참조는 우측값 + 참조이다.
void func(int&& a) { a = 3; }
int q = 3;
int &p = q;
func(move(p));
여기서 q, p의 값은 모두 3이다. 우측값으로 넘겨주었지만 참조라 값이 변한 것이 원본에 영향을 미친다.

int q = 1;
func(move(q));
이것도 마찬가지로 q의 값은 3이다. 우측값으로 넘겼지만 참조라 q의 값이 func() 함수 때문에 변한다.

- move() 주의점
void func(int &&a)
{
	int b = a; // a는 우측값으로 받았지만 이름이 있기에 다시 좌측값으로 치기에 복사가 발생함
	int c = move(a); // a는 move()로 인해 우측값이 되어 이동 연산이 가능해진다.
}
함수를 짜는 경우에 위와 같은 경우를 잘 생각해야 한다.

class A {};
void func(A& a) {}
void func(A&& a) {}
이러한 코드에서 func(A())는 void func(A&& a) {}가 호출된다. A()는 생성자로 임시 생성된 임시객체이기 때문에 우측값이다.

- 보편적(템플릿) 참조
void func(int&& a) {}
위와 같은 함수가 있다고 하자
func(1) -> 우측값이라 가능하다.
func(A) -> A라는 변수는 좌측값이라 불가능하다.
그렇다면 func(A)이러한 짓을 위해 void func(int& a) {}라는 함수를 추가적으로 더 만들어줘야 한다.
여간 귀찮은 일이다.

하지만 템플릿 프로그래밍을 사용하면 이 귀찮은 짓을 덜 수가 있다.
template <class T>
void func(T&& a) { /* 어떤 행동 */ }
이러한 함수가 있다면 func(1), func(A) 모두 커버가 가능하다. 굳이 추가적으로 T&, const T&에 대한 함수를 따로 작성하지 않아도 된다.

- forward 형변환 (사실은 forward는 함수)
template <class T>
void subfunc(T&& p) {  }

template <class T>
void func(T&& a) { subfunc(a); }
이러한 두 함수가 존재한다고 하면 func에서 호출하는 subfunc(a)에서 문제가 발생하는데 func() 내부에서 사용되는 a는 우측값 참조로 받았지만 이름이 있는 상태이기에 좌측값으로 취급이 된다.
그러면 subfunc() 함수는 T& a를 가정하고 참조 a를 받는 함수로만 컴파일러가 취급한다.
이를 해결하기 위해 forward 형변환이 필요하다. 밑과 같이 작성한 func() 함수는 이러한 문제를 해결한다.
template <class T>
void func(T&& a) { subfunc(forward<T>(a)); }
이렇게 작성하면 func() 내부에서는 우측값이면 subfunc(move(a))로 수행되고 좌측값이면 subfunc(a)로 수행된다.

자동으로 메모리 해제해주는 스마트 포인터가 있다.
- 스마트 포인터 unique_ptr
소유권은 유일해야 한다. 즉 객체를 가리키는 포인터는 무조건 하나여야 한다.
unique_ptr<int> A(new int(1));
unique_ptr<int> A = make_unique<int>(1);
위와 같이 사용하면 되고 실제 값을 얻거나 포인터 위치를 참조할 때는 기존 포인터와 동일하게 *A, A(또는 A.get()) 이렇게 사용한다.
메모리 해제는 별 신경을 쓸 필요가 없다. 블록을 벗어나던 아니던 포인터가 쓰이지 않는다고 판단되면 알아서 해제한다.
스마트 포인터라고 해서 포인터를 함수에 넘기거나 하는 경우 더 특별한 것은 없다.
unique_ptr<int> A(new int(1));
void func(int* ptr) {}
이렇게 한 뒤에 func(A); 하면 된다. 기존의 포인터를 인자로 받는 함수와 같다.
unique_ptr은 말 그대로 유니크하기 함부로 = 로 포인터를 더 연결할 수 없다.
밑의 예시를 보면
unique_ptr<int> A(new int(1)), B;
B = A; // 안된다. A의 값을 가리키는 포인터는 A 뿐이여야 한다.
B = move(A); // 된다. 하지만 기존 A는 껍데기가 된다.
A의 주소를 보면 00000000으로 나오고 기존의 A의 주소가 B의 주소가 된 것을 알 수 있다.
예시 한 가지 더!
vector<std::unique_ptr<A>> vec;
unique_ptr<A> pa(new A(1));
vec.push_back(pa); // 될까? 안된다. unique_ptr의 소유권은 유일해야 한다.
vec.push_back(std::move(pa)); // 잘 된다. 단지 기존의 pa가 껍데기가 될 뿐...

class A
{
public:
	A(int a){};
	A(const A& a) = delete;
};
여기서 A(const A& a) = delete; 이러한 표현이 가능한데 = delete를 하게 되면 A의 생성자를 명시적으로 사용하지 않겠다는 것이다. 
따라서 A temp(1); 이러한 표현은 불가능하다는 것이고 보통 객체가 하나여야 하는 싱글턴 패턴에서 자주 사용한다.



