- explicit 키워드
암시적 변환 금지 시킴, 암시적 복사 생성자 호출 금지
예시) 
long p = 3;
char K = p; 이건 가능하지만 만약에서 long 형 변환에 explicit이 붙어있다면 컴파일러는 에러를 내뿜는다.
char K = long(p); 이렇게 해야 에러 없이 진행 가능하다.
즉 모든 것을 명시적으로 하게 만드려면 함수나 생성자 앞에 explicit을 붙이면 된다.

- mutable 키워드
밑과 같은 클래스 const 함수는 클래스 내의 멤버 변수를 바꿀 수 없다.
void DoSomething(int x) const { }
하지만 클래스 내의 멤버 변수가 mutable int a; 이렇게 mutable이 붙어 선언이 되었다면 클래스 const 함수 내에서 멤버 변수를 바꿀 수 있다.
이런 애를 쓰는 이유는 이 함수를 사용하는 인터페이스로 보아서는 const가 붙어야 하는데 내부적으로 클래스 멤버 변수를 변경해야 하는 함수면 이를 사용한다.

- static_cast
그냥 C언어의 형변환과 같다고 보면 된다. 컴파일 시간에 형변환이 옳은지 아닌지를 판단한다.
예를 들어 static_cast<int>(float_variable); 이 표현은 (int)(float_variable) 이 표현과 동일하다.

- const_cast
상수성을 없애는 데 사용된다. 포인터, 참조, 우측값 참조에 대해서만 사용이 가능하다.
또한 const int& 형을 int&로 바꾸는 것은 가능하나 const int& 형을 double&로 바꾸는 것은 불가하다. 즉 데이터형은 같고 const만 띄어내거나 붙일 수 있는 것이다.
예시는 다음과 같다.
const double &&PI = 3.14;
double&& Easy_Pi = const_cast<double&&>(PI);
Easy_Pi = 3;
const_cast를 이용하여 PI 값을 const형이 아닌 데이터형으로 받아 자유롭게 변환하여 사용할 수 있다.

- reinterpret_cast
어떠한 타입도 변환이 가능한 자유로운 형변환이다. 문제는 자유로운 만큼 위험하기에 형변환 하는 두 변수 사이의 정확한 관계가 정리 되었을 경우에만 사용해야 한다.
예시는 밑과 같다.
const char* pointer = "this is void";
long long val = reinterpret_cast<long long>(pointer);
해당 char 문자열의 주소를 long long으로 받는데 사용한 것이다.
컴파일러에 따라 reinterpret_cast는 다르게 작동할 수 있기 때문에 왠만하면 안쓰는 것이 좋다.

- dynamic_cast
런타임에 동적으로 형변환을 결정하는 캐스팅이다. 다형성을 가진 클래스에 대해서만 캐스팅이 가능하다.
밑은 dynamic_cast의 대표적인 예시이다.
class Creature { };
class Human : public Creature { };
Creature* me = new Human;
DerivedClass* pSDC = dynamic_cast<DerivedClass*>(pBC);
이렇게 상속을 받은 클래스를 어떤 경우는 Human 어떤 경우는 Creature로 변환하여 사용하고 싶은 경우 dynamic_cast 캐스팅을 사용하게 된다.
문제는 이러한 경우 static_cast도 동일한 역할을 할 수 있다.
단지 dynamic_cast가 가진 차별점은 비용이 좀 더 비싸 시간을 더 잡아먹는 대신에 형변환이 불가능하거나 잘못되는 경우에는 NULL 포인터를 반환하는 것이다.
즉 형변환이 잘못될 일이 없는 부분에는 처리 비용을 아끼기 위해 static_cast를 사용해야한다.
dynamic_cast의 특징을 이용한 예시는 밑과 같다.
class Creature {
	virtual void Breath() {};
};

class Human : public Creature {
public:
	void Study() {};
};

class Dog : public Creature {};

class Monster : public Creature {
public:
	void Kill_Somthing() {};
};

int main()
{
	std::vector<Creature*> Train;

	Creature* whoisit = new Human();
	if (whoisit) {
		Human* me = static_cast<Human*>(whoisit); // 형변환이 잘못될 일이 없다. 따라서 비용이 싼 static_cast를 사용한다.
		me->Study();
	}

	Train.push_back(new Human());
	Train.push_back(new Dog());
	Train.push_back(new Monster());

	for (auto creature : Train) {
		Monster* bad_creature = dynamic_cast<Monster*>(creature); // Creature* 형이 항상 Monster*로 할당된 것이 아니기에 형변환이 잘못될 가능성이 있다.
		if (bad_creature) // 따라서 형변환이 잘못되는 경우를 판단하기 위해 dynamic_cast를 사용하여 던져준 값이 nullptr인지 아닌지를 검사한다.
		{
			bad_creature->Kill_Somthing();
		}
	}
}
위의 예시는 기차에 사람, 개, 몬스터가 담길 수 있는데 몬스터가 담기는 경우를 검사하는 코드이다.
기차는 생명체 포인터 형으로 되어 있는 std::vector<>로 모든 생명체는 다 담길 수 있다.
주의점이 있는데 Creature 클래스에 virtual void Breath() {}; 를 지우면 Creature 클래스에 대해 dynamic_cast를 할 수 없다.
클래스 내부에 virtual이 단 하나라도 있어야 가상 테이블이 만들어지고 이를 통해 컴파일러가 Creature 클래스가 다형성을 가진 클래스라는 것을 인지하게 된다.

보통 함수 호출보다 virtual이 붙은 함수 호출하는 시간이 더 오래걸린다.
클래스 포인터 다룰 때 항상 더 큰 녀석(자식)을 더 작은 녀석(부모)에게 줄 수 있다는 것을 인지하자 (그 반대는 안된다.)
다이아몬드 상속 문제(다중 상속에서 발생하는 문제)를 해결하는 virtual 상속에 대해 기억하기!

탬플릿 사용시에는 template <class T>보다는 template <typename T> 이용하기

- 함수는 아니지만 함수인 척을 하는 녀석 Funtor
예시)
struct Comp {
  bool operator()(int a, int b) { return a > b; }
};
Comp compare;
int a = 3, b = 1;
cout << compare(a, b);
이런 짓이 가능해서 템플릿 프로그래밍에서 비교연산자 재정의해서 쓰기보다 이러한 Funtor를 넘겨 오름차순, 내림차순을 바꾸게 된다.

템플릿 template <typename T, int num = 5> 이런 문법 가능

대표적인 쓰임새 예시)
template <typename T>
struct Compare {
  bool operator()(const T& a, const T& b) const { return a < b; }
};

template <typename T, typename Comp = Compare<T>>
T Min(T a, T b) {
  Comp cmp;
  if (cmp(a, b)) {
    return a;
  }
  return b;
}

템플릿 함수를 작성할 때 그 순서에 유의할 것.

#define SIZE 10 // C-style
constexpr int size = 10; // modern C++

템플릿 메타 프로그래밍에서 들어가는 인수는 상수여야 한다.

밑과 같은 경우가 템플릿 메타 프로그래밍인데 여기서 함수 인자와 같이 들어가게 되는 N은 무조건 const 형과 같은 상수여야 한다.
template <int N>
struct Factorial {
	static const int result = N * Factorial<N - 1>::result;
};

template <>
struct Factorial<1> {
	static const int result = 1;
};

Factorial<k>::result
여기서 k는 상수가 아니면 에러다. 템플릿 메타 프로그래밍은 무조건 컴파일 시간에 결정될 수 있는 것만 가능하다.

typedef vector<int> VecInt;
using VecInt = vector<int>;

typedef void (*func)(int, int);
using func = void (*)(int, int);

함수 객체(Funtor)에는 절대로 특정 상태를 저장해서 이에 따라 결과가 달라지는 루틴을 짜면 안된다.
이는 C++ 컴파일러마다 STL 인터페이스는 같지만 구현 방식이 천차만별이기 때문이다.

- 람다 활용성
vec.erase(std::remove_if(vec.begin(), vec.end(), [](int i) -> bool { return i % 2 == 1; })
위와 같이 "벡터에서 홀수인 원소 지우기"를 수행하는 코드를 간결하게 작성가능하다.

lvalue(좌측값) rvalue(우측값)에 대한 정의
좌측값 = 대입 시에 왼쪽 혹은 오른쪽에 오는 식, ex) int p; int a = p; -> a, p 모두 좌측값
추가적으로 좌측값은 어떠한 메모리 위치를 가리키고 있는 값이라고도 볼 수 있다.
우측값 = 대입 시에 오직 오른쪽에만 오는 식, ex) int a = 3; -> 여기서 3이 우측값 / int q, p; int a = p * q; -> 여기서 p * q 는 우측값
int func() { int a = 1; return a; } -> 여기서 func()는 우측값이다. 왜냐하면 func() = 3; 이건 불가능하기 때문

&는 좌측값 참조다.
잘 알다싶이 다음 예시와 같이 보통 쓰임
void StringFunc(string &str) { str = "changed"; }
void StringFunc(const string &str) { cout << "str is const var" << endl; }

&&는 우측값 참조다.
int &b = 3; 이렇게 사용은 안되지만 int &&b = 3; 이런 표현은 가능하다.
int p = 1, q = 2; int &&b = p + q; 이런 임시 우측값을 담는 표현도 가능하다.
우측값 참조의 대표적인 쓰임은 컴파일러로 하여금 컴파일 시간에 어떤 인자로 좌측값이 오는지 우측값이 오는지에 따라 오버로딩을 할 수 있도록 도와주는 것이다.
기본적으로 int p = 1;을 수행하면 값 1은 p에 복사되고 1에 필요한 메모리는 없어진다.
반면 int &&p = 1;을 수행하면 값 1에 필요한 메모리는 사라지지 않고 이 메모리를 p는 가리키게 된다. 
마치 1에 temp라는 별명을 쥐어주고 temp를 가리키는 것과 같다.
int temp = 1; int &p = temp; 이 코드와 비슷한 효과를 낸다. (물론 우측값 참조는 int temp = 1; 이러한 과정이 없으므로 더 빠르다.)
int &a = b + c -> 불가능
int &&a = b + c -> 가능, 속도 빠름
int a = b + c -> 가능, 속도 느림
우측값 참조로 된 a는 b + c 의 결과가 반영된 임시객체를 가리키게 된다.
속도가 빨라지는 이유는 int a = b + c 이 경우 b + c 결과가 a에 복사된다.
연산 순서는 b + c 연산 후 객체 생성 -> b + c 객체를 a로 복사 -> b + c 객체 파괴 이렇게 3번의 연산이 이루어진다. 
반면 int &&a = b + c 의 연산 순서를 보면 b + c 연산 후 객체 생성 -> a는 b + c 객체를 참조 이렇게 복사가 이루어지는 곳이 없이 순조롭게 연산이 끝난다.
간단히 &&는 우측값의 생명 주기를 연장해준다고 생각하면 된다.

class Mover
{
	int m_var;
public:
	void func(int a) { m_var = a; }
	void func(int& a) { m_var = a; }
	void func(const int& a) { m_var = a; }
	void func(int&& a) { m_var = a; }
};
위와 같은 클래스에서 4가지 func를 비교해보겠다.

1. void func(int a) { m_var = a; }
함수 인자를 받을 때 a로 값이 복사되어 한 번 복사가 발생되고 m_var에 a 값을 옮기는 과정에서 복사 한 번이 더 발생한다.
총 복사: 2번

2. void func(int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
인자로 좌측값만 받을 수 있다.
총 복사: 1번

3. void func(const int& a) { m_var = a; }
참조로 받은 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다. (a는 const로 변경불가 할 뿐 참조로 받은 것이다.)
인자로 우측값과 좌측값 모두 받을 수 있다.
총 복사: 1번

4. void func(int&& a) { m_var = a; }
여기서 주의할 것은 int&& a에서 a는 좌측값이다. (a라는 별명, 즉 실체가 있을 때는 좌측값으로 취급된다.)
좌측값 a를 m_var에 옮기는 과정에서 복사가 1번 일어난다.
총 복사: 1번

2, 3, 4번은 모두 복사가 1번 이루어지는데 사용하는 이유가 있다.
2번은 좌측값만 취급하기에 func(1) 과 같은 것을 다루지 못한다.
3번은 func(1), func(p) 좌측, 우측값을 모두 다루지만 함수 내부에서 값 변경을 할 수 없다.
4번은 func(1), func(1+2) 등 우측값을 다룰 수 있고 내부에서 함수 인자를 바꿀 수도 있다. (밑의 함수 처럼 말이다.)
void func(int&& a) { a = 3; m_var = a; } -> func(100)을 해도 m_var = 3이다.
보통 함수 인자 넘길 때 복사가 발생하지 않게 하기 위해서는 밑과 같이 우측값 참조자를 사용한 것과 그냥 참조자를 사용한 것 두 가지를 모두 정의한다. (이러면 좌측값, 우측값이 모두 의도한 데로 커버된다.)
void func(int&& a) { m_var = a; }; void func(int& a) { m_var = a; }

우측값 참조를 효율적으로 이용하기 위한 move()

template <typename T>
void swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}
해당 함수를 보면 복사가 3번 발생한다.
생성자가 복사 생성자라 복사 발생 -> 1
a = b에서 복사 발생 -> 2
b = tmp에서 복사 발생 -> 3
복사가 총 3번 발생하는데 자료형 T의 크기가 크면 클수록 속도가 많이 느려질 것이다.

template <typename T>
void swap(T &a, T &b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}
복사가 발생하는 구간이 없이 모두 이동 생성이다.
복사 생성보다는 이동 생성이 빠르고 좌측값을 우측값으로 바꾸어 이동 생성을 가능하게 하는 것이 바로 move() 함수이다.
물론 이렇게 이동 생성으로 득을 보려면 자료형 T에 T& T::operator=(T&& s) 이러한 대입 연산자 오버로딩을 따로 만들어 줘야 한다.
중요한 것은 = 연산자에 의해서 이동이 발생한는 것이지 move() 함수에서 이동이 발생하는 것이 아니라는 것이다.

move() 예시를 좀 더 들어보면 우측값 참조는 우측값 + 참조이다.
void func(int&& a) { a = 3; }
int q = 3;
int &p = q;
func(move(p));
여기서 q, p의 값은 모두 3이다. 우측값으로 넘겨주었지만 참조라 값이 변한 것이 원본에 영향을 미친다.

int q = 1;
func(move(q));
이것도 마찬가지로 q의 값은 3이다. 우측값으로 넘겼지만 참조라 q의 값이 func() 함수 때문에 변한다.

- move() 주의점
void func(int &&a)
{
	int b = a; // a는 우측값으로 받았지만 이름이 있기에 다시 좌측값으로 치기에 복사가 발생함
	int c = move(a); // a는 move()로 인해 우측값이 되어 이동 연산이 가능해진다.
}
함수를 짜는 경우에 위와 같은 경우를 잘 생각해야 한다.

class A {};
void func(A& a) {}
void func(A&& a) {}
이러한 코드에서 func(A())는 void func(A&& a) {}가 호출된다. A()는 생성자로 임시 생성된 임시객체이기 때문에 우측값이다.

- 보편적(템플릿) 참조
void func(int&& a) {}
위와 같은 함수가 있다고 하자
func(1) -> 우측값이라 가능하다.
func(A) -> A라는 변수는 좌측값이라 불가능하다.
그렇다면 func(A)이러한 짓을 위해 void func(int& a) {}라는 함수를 추가적으로 더 만들어줘야 한다.
여간 귀찮은 일이다.

하지만 템플릿 프로그래밍을 사용하면 이 귀찮은 짓을 덜 수가 있다.
template <class T>
void func(T&& a) { /* 어떤 행동 */ }
이러한 함수가 있다면 func(1), func(A) 모두 커버가 가능하다. 굳이 추가적으로 T&, const T&에 대한 함수를 따로 작성하지 않아도 된다.

- forward 형변환 (사실은 forward는 함수)
template <class T>
void subfunc(T&& p) {  }

template <class T>
void func(T&& a) { subfunc(a); }
이러한 두 함수가 존재한다고 하면 func에서 호출하는 subfunc(a)에서 문제가 발생하는데 func() 내부에서 사용되는 a는 우측값 참조로 받았지만 이름이 있는 상태이기에 좌측값으로 취급이 된다.
그러면 subfunc() 함수는 T& a를 가정하고 참조 a를 받는 함수로만 컴파일러가 취급한다.
이를 해결하기 위해 forward 형변환이 필요하다. 밑과 같이 작성한 func() 함수는 이러한 문제를 해결한다.
template <class T>
void func(T&& a) { subfunc(forward<T>(a)); }
이렇게 작성하면 func() 내부에서는 우측값이면 subfunc(move(a))로 수행되고 좌측값이면 subfunc(a)로 수행된다.

자동으로 메모리 해제해주는 스마트 포인터가 있다.

- 스마트 포인터 unique_ptr
소유권은 유일해야 한다. 즉 객체를 가리키는 포인터는 무조건 하나여야 한다.
unique_ptr<int> A(new int(1));
unique_ptr<int> A = make_unique<int>(1);
위와 같이 사용하면 되고 실제 값을 얻거나 포인터 위치를 참조할 때는 기존 포인터와 동일하게 *A, A(또는 A.get()) 이렇게 사용한다.
메모리 해제는 별 신경을 쓸 필요가 없다. 블록을 벗어나던 아니던 포인터가 쓰이지 않는다고 판단되면 알아서 해제한다.
스마트 포인터라고 해서 포인터를 함수에 넘기거나 하는 경우 더 특별한 것은 없다.
unique_ptr<int> A(new int(1));
void func(int* ptr) {}
이렇게 한 뒤에 func(A); 하면 된다. 기존의 포인터를 인자로 받는 함수와 같다.
unique_ptr은 말 그대로 유니크하기 함부로 = 로 포인터를 더 연결할 수 없다.

밑의 예시를 보면
unique_ptr<int> A(new int(1)), B;
B = A; // 안된다. A의 값을 가리키는 포인터는 A 뿐이여야 한다.
B = move(A); // 된다. 하지만 기존 A는 껍데기가 된다.
A의 주소를 보면 00000000으로 나오고 기존의 A의 주소가 B의 주소가 된 것을 알 수 있다.

예시 한 가지 더!
vector<std::unique_ptr<A>> vec;
unique_ptr<A> pa(new A(1));
vec.push_back(pa); // 될까? 안된다. unique_ptr의 소유권은 유일해야 한다.
vec.push_back(std::move(pa)); // 잘 된다. 단지 기존의 pa가 껍데기가 될 뿐...
vec.emplace_back(new A(1)); // 중간 다리 없이 하고 싶다면 emplace_back을 사용해도 된다.

class A
{
public:
	A(int a){};
	A(const A& a) = delete;
};
여기서 A(const A& a) = delete; 이러한 표현이 가능한데 = delete를 하게 되면 A의 생성자를 명시적으로 사용하지 않겠다는 것이다. 
따라서 A temp(1); 이러한 표현은 불가능하다는 것이고 보통 객체가 하나여야 하는 싱글턴 패턴에서 자주 사용한다.

기존의 동적 할당과 비교하면 밑과 같이 다르다.

class A {
	int p;
public:
	A() { p = 1; }
	A(int k) { p = k; cout << "생성됨\n"; }
	~A() { cout << "해제됨\n"; }
};

// 기존의 방식
vector<A*> pAry;
for (int i = 0; i < 10; i++)
{
	A* ptr = new A();
	pAry.push_back(ptr);
}
cout << "소멸 호출\n";
while (!pAry.empty()) {
	delete pAry.back();
	pAry.pop_back();
}
일일이 해제해야 한다.

// unique_ptr을 사용한 방식
vector<unique_ptr<A>> pAry;
for (int i = 0; i < 10; i++)
{
	unique_ptr<A> ptr = make_unique<A>();
	pAry.push_back(move(ptr));
}
cout << "소멸 호출\n";
따로 할당 해제에 대한 코드를 넣을 필요가 없다.

- 스마트 포인터 shared_ptr
포인터에 대한 소유권이 유일하지 않아도 된다.
따라서 unique_ptr과 다르게 객체를 몇 개의 포인터가 가리키는지 알 수 있는 참조횟수가 도입되는데 이 참조횟수를 기록하는 객체에 대한 공간이 따로 할당된다.
shared_ptr<int> A(new int(1)), B;
B = A; // 가능하다.
위의 경우 B, A는 모두 같은 곳을 가리키게 된다.

밑의 경우가 특이한데
std::vector<std::shared_ptr<int>> vec;
vec.push_back(std::shared_ptr<int>(new int(1)));
vec.push_back(std::shared_ptr<int>(vec[0]));
vec.push_back(std::shared_ptr<int>(vec[1]));
이러한 경우 vec[0], vec[1], vec[2] 이 세개의 포인터는 모두 같은 곳을 가리키게 된다.
이러한 시점에서 vec.erase(vec.begin());을 몇번 수행해야 이 포인터가 할당 해제가 될까?
3번해야 할당된 shared_ptr이 해제가 된다. 위의 경우 참조 횟수는 3번이 된다.
shared_ptr은 자신의 참조 횟수가 0이 되는 순간 해제하는 특징이 있다.

shared_ptr의 참조횟수는 use_count()라는 함수로 알 수 있다.
shared_ptr<int> A(new int(1));
A.use_count(); // 이런 식으로 사용한다.
여기서 A의 참조 횟수는 1이다.

shared_ptr 생성방식도 unique_ptr과 거의 비슷한데 한가지 주의사항이 있다.
std::shared_ptr<int> p1(new int(1));
얘는 int 값 1을 가진 녀석을 동적할당한다.
그 후에 shared_ptr 포인터로 동적할당한 녀석을 가리키면서 shared_ptr의 참조횟수를 담고있는 객체를 동적할당한다.
일단 여기서 값비싼 연산인 동적할당 2번이 발생한다.
std::shared_ptr<int> p1 = std::make_shared<int>(1);
얘는 그와 다르게 shared_ptr의 참조횟수를 담고있는 객체와 int 값 1을 가진 녀석을 한방에 동적할당하여 연산이 더 적다.
그니까 바람직하게 std::make_shared<int>(); 이 녀석을 사용하도록 하자.

int* p = new int(1);
shared_ptr<int> pA(p);
shared_ptr<int> pB(p);
위 예시를 보면 pA와 pB의 참조횟수를 담고있는 객체는 다르다.
따라서 pA.use_count()와 pB.use_count()는 모두 1이다.
따라서 pA와 pB 중 하나라도 참조횟수가 0이 된다면 1을 담고있던 값을 가리키턴 포인터 p는 할당 해제될 것이다.
이때 오류가 발생하는데 만약 pA의 참조횟수가 0이 되어 p를 해제하게 된다면 pB의 참조횟수는 아직 1이라 pB가 가리키는 포인터는 아직 해제가 안된줄 알고 있게 된다.
이는 모순적인 상황이고 결과적으로 p에 대한 소멸자가 두번 호출되게 되어 컴파일러는 에러를 출력하게 된다.

int* p = new int(1);
shared_ptr<int> pA = shared_ptr<int>(p); // 또는 비효율적이게 shared_ptr<int> pA(p);
shared_ptr<int> pB = shared_ptr<int>(pA); // 여기서 shared_ptr<int> pB = shared_ptr<int>(p);는 오류이다. 이미 p에 대해 생성된 공유 포인터를 다시 생성할 수는 없다.
반면 위와 같이 shared_ptr<int> 객체를 새로 생성하는 것이 아니라 shared_ptr<int>가 가리키는 포인터를 직접 가져다 주면 해결된다.
이때 참조횟수를 담고있는 객체를 pA와 pB가 모두 공유하게 되고 pA.use_count()와 pB.use_count()는 모두 2이다.

위의 예시도 약간의 문제가 있는데 원본 포인터 p를 이용하여 p에 대해 생성된 공유 포인터를 바로 알 수가 없다는 것이다.
따라서 클래스를 사용한다면 밑과 같이 enable_shared_from_this</* 클래스 */> 를 상속하는 것이 좋다.
class A : public std::enable_shared_from_this<A> {
	int p;
public:
	A() { p = 1; }
	A(int k) { p = k; }
};

A* p = new A(1);
shared_ptr<A> pA = shared_ptr<A>(p); // 여기서 shared_ptr<A> pA = p->shared_from_this(); 이렇게 해버리면 오류다. 아직 p에 대한 공유 포인터가 정의되지도 않았기 때문이다.
shared_ptr<A> pB = p->shared_from_this();
enable_shared_from_this 이 녀석을 상속하면 shared_from_this()라는 함수가 따라오는데 얘가 객체의 shared_ptr을 가져온다.
명심할 점은 shared_from_this()는 shared_ptr이 정의된 객체에서만 사용해야 한다는 것이다.

shared_ptr을 사용할 때 블록 범위를 잘 고려해야 한다. 특정 블록에서 정의된 shared_ptr은 그 블록 안에서만 참조를 하게 되고 벗어나는 순간 참조 횟수 1개를 깎는다.
shared_ptr<int> pA;	
if (true) {
	shared_ptr<int> pB = make_shared<int>(1);
	pA = pB;
	// 이 순간의 pA의 참조 횟수는 2이다.
}
// 이 순간의 pA의 참조 횟수는 1이다. pB는 더 이상 없기 때문이다.


shared_ptr는 문제점이 있는데 바로 순환 참조이다.
다음 예시로 알 수 있다. 한 명의 사람은 어떤 모임에 속하게 될 것이고 어떤 모임은 여러 명의 사람을 담고 있을 것이다.
-----------------------------------------------------------------------------------------------------
class User;

class Group
{
	vector<shared_ptr<User>> m_GroupList;
public:
	Group() { cout << "Group 생성됨.\n"; }
	~Group() { m_GroupList.clear(); cout << "Group 소멸됨.\n"; }
	void AddUser(shared_ptr<User> user) { m_GroupList.push_back(user); }
};

class User 
{
	shared_ptr <Group> m_Belong;
	int m_Num;
public:
	User(int i) { m_Num = i; cout << i << "번째 User 생성됨.\n"; }
	~User() { cout << m_Num << "번째 User 소멸됨.\n"; }
	void SetGroup(shared_ptr<Group> group) { m_Belong = group; }
};

int main()
{
	shared_ptr<Group> pGroup = make_shared<Group>();

	for (int i = 0; i < 10; i++) {
		shared_ptr<User> pUser = make_shared<User>(i);
		pGroup->AddUser(pUser);
		pUser->SetGroup(pGroup);
	}
}
-----------------------------------------------------------------------------------------------------
이 예시에서 for문 내에서 생성된 10개의 User 객체는 생성만 되고 소멸은 되지 못한다. 그를 담고있는 Group도 소멸되지 못한다.
Group 1개와 User 10개의 생성자만 호출될 뿐이다. 이는 순환 참조 문제 때문이다.
pGroup이 가진 vector 배열은 10개의 User 공유포인터를 가지고 각 공유포인터들은 동적 생성된 User를 가리킨다.
그러면 일단 i가 0인 경우만 분석해보자.
shared_ptr<User> pUser = make_shared<User>(i); 에서 i가 0인 경우 객체가 동적 생성되었고 이때 참조횟수가 1개 증가한다. 
이때 pGroup->AddUser(pUser); 하면서 m_GroupList[0]가 만들어지고 해당 공유 포인터의 참조횟수가 1개 증가하여 m_GroupList[0]의 참조횟수는 2가 된다.
그 다음 pUser->SetGroup(pGroup); 이 구문이 진행되면서 i가 0인 경우 동적 할당된 객체의 Group이 지정된다.
이 때 m_Belong은 pGroup을 가리키게 되고 pGroup 공유 포인터의 참조 횟수는 1개 증가된다. (i가 0일 때 pGroup 참조 횟수는 1개일 것이다.)
이렇게 m_GroupList[0]과 pGroup의 참조횟수가 서로 0 이상인 경우 이 둘을 갑자기 해제하는 상황을 생각해보자.
먼저 컴파일러는 공유 포인터 pGroup에 연결된 객체를 해제하려고 할 것이다. (엄격하게는 m_GroupList[0] 이 녀석에 연결된 녀석부터 해제하려 하겠지만 설명할 때 순서는 별 상관없다.)
해제하려고 보니 해당 객체에는 m_GroupList[0]이라는 공유 포인터가 있었고 해당 공유 포인터는 참조 횟수가 0 이상이라 해제할 수가 없는 상황이다.
이를 해제할 수가 없으니 pGroup은 해제가 되지 않고 m_GroupList[0] 이 녀석의 참조 횟수가 0이 되는 순간을 기다리게 된다.
그렇다면 m_GroupList[0] 이 녀석의 참조 횟수가 0이 되는 것이 가능할까? 불가능하다.
이유는 m_GroupList[0]가 가리키는 User 객체를 해체하려하면 User 객체의 공유 포인터 m_Belong이 pGroup을 가리키고 있어 참조 횟수가 1이라 이를 못하게 한다.
따라서 서로의 멤버 변수 공유 포인터의 참조 횟수가 0이 아니라 서로 동적 할당 해체를 하지 못하고 소멸자도 호출되지 못하는 것이다.
이는 shared_ptr의 고질적인 문제로 이를 해결하려면 weak_ptr이 필요하다.
그리고 예시에 보았듯이 unique_ptr과 다르게 shared_ptr을 인자로 받는 함수는 명확하게 shared_ptr이라고 밑 예시와 같이 명시해주어야 한다. (이는 weak_ptr도 마찬가지이다.)
void SetGroup(shared_ptr<Group> group) { m_Belong = group; }

- 스마트 포인터 weak_ptr
shared_ptr은 weak_ptr이 될 수 있다. (형변환이 된다.)
weak_ptr은 shared_ptr과 다르게 1을 초과하여 참조횟수를 늘리지 않는다.

shared_ptr<int> pA = make_shared<int>(1), pB, pC, pD;
pB = pC = pD = pA;
이 상태에서 pA의 참조 횟수는 4이다.

shared_ptr<int> pShare = make_shared<int>(1);
weak_ptr<int> pA = pShare, pB, pC, pD;
pB = pC = pD = pA;
반면 이 상태에서 pA의 참조 횟수는 1이다.
주의할 점은 weak_ptr<int> pA = make_shared<int>(1); 이렇게 사용해버리면 pA는 이상한 곳을 가리키게 된다. 따라서 실제 공유 포인터를 거친 후에 그 것을 이용해서 넘겨야 한다.
위의 경우에서 pA, pB, pC, pD 중 어느 하나라도 해제 되면 참조 횟수가 0이 되어버려 실제 할당된 객체가 해제되어버려 나머지 weak_ptr은 허상을 가리키고 있는 것이 되어버린다.
허상의 주소값을 호출하는 것을 방지하기 위해 weak_ptr의 주소를 실제로 알기위해서는 한 단계의 함수를 거쳐서 호출하게 되어있는데 그 것이 lock 함수이다.
위 코드 예시에서 pA의 실제 주소를 알려면 pA.lock() 이렇게 해야한다.
lock() 함수는 pA가 허상의 주소 즉, 이미 해제된 객체를 가리키고 있다면 false(nullptr)를 반환하고 아니라면 주소값에 해당하는 shared_ptr을 반환한다.

---------------------------------------------------------------------------------------
weak_ptr<int> pA, pB;
if (true) {
	shared_ptr<int> pShare = make_shared<int>(200);
	pB = pA = pShare;
	cout << (pA.lock() ? "포인터 값: " + to_string(*pA.lock()) : "포인터는 null 값") << "\n";
}
cout << (pA.lock() ? "포인터 값: " + to_string(*pA.lock()) : "포인터는 null 값") << "\n";
---------------------------------------------------------------------------------------
이 예시에서 출력 값은 다음과 같다.
---------------------------------------------------------------------------------------
포인터 값: 200
포인터는 null 값
---------------------------------------------------------------------------------------
pShare 포인터의 참조 횟수는 if문 안에서 1이지만 if문을 벗어나면 0이 된다.
따라서 if문 안에서는 weak_ptr인 pA는 공유 포인터인 pShare를 가리키고 실제 주소가 존재하니 pA.lock() 값이 nullptr이 아니라 실제 객체의 값이 출력된다.
if문 밖에서는 pShare이 해제되었으니 pA는 허상을 가리키게 되면서 pA.lock()에서 nullptr이 도출되고 이로 인해 포인터는 null 값이라는 결과가 출력된다.
pB = pA = pShare; 이 구문을 수행하는 시점에서도 pA, pB의 참조 횟수는 최대 1로 증가하지 않는다.

그렇다면 아까 shared_ptr로 짰던 Group과 User 클래스 예시를 weak_ptr로 짜보자.
-----------------------------------------------------------------------------------------------------
class User;

class Group
{
public:
	vector<weak_ptr<User>> m_GroupList;
public:
	Group() { cout << "Group 생성됨.\n"; }
	~Group() { m_GroupList.clear(); cout << "Group 소멸됨.\n"; }
	void AddUser(weak_ptr<User> user) { m_GroupList.push_back(user); }
	void PopUser() { m_GroupList.pop_back(); }
};

class User
{
public:
	weak_ptr <Group> m_Belong;
	int m_Num;
public:
	User(int i) { m_Num = i; cout << i << "번째 User 생성됨.\n"; }
	~User() { cout << m_Num << "번째 User 소멸됨.\n"; }
	void SetGroup(weak_ptr<Group> group) { m_Belong = group; }
};

int main()
{
	shared_ptr<Group> pGroup = make_shared<Group>();

	for (int i = 0; i < 10; i++) {
		shared_ptr<User> pUser = make_shared<User>(i);
		pGroup->AddUser(pUser);
		pUser->SetGroup(pGroup);
	}
}
-----------------------------------------------------------------------------------------------------
실행 후 출력을 보면 생성과 해제가 모두 잘 이루어지는 것을 알 수 있다.
i가 0인 경우부터 생각해보자.
공유 포인터인 pUser는 make_shared로 생성되고 참조 횟수가 1이 된다. 그 후에 AddUser를 수행하여 weak_ptr인 m_GroupList[0]의 참조횟수도 1이 된다.
그 후에 SetGroup() 함수로 인해 공유 포인터 pGroup을 weak_ptr인 m_Belong이 가리키게 된다. 당연히 pGroup은 공유 포인터라 참조횟수는 weak_ptr과 따로 돌기에 1에서 증가하지 않는다.
그 후 for문의 블록이 다시 돌아가기에 공유 포인터 pUser가 해제되면서 pUser와 연결되어있던 m_GroupList[0]은 허상의 공간을 가리키게 된다.
이러한 루틴이 for문에서 10번 반복되고 맨 마지막에 공유 포인터 pGroup이 해제되면서 이에 연결되어 있던 weak_ptr인 m_Belong들은 허상의 공간을 가리키게 된다.
이렇게 weak_ptr은 허상을 가리킬 수 있는 위험성이 있기에 lock()이라는 중간 다리를 건너야 한다.
중간 다리를 건너는 과정으로 인해 오버헤드가 발생하기에 왠만하면 weak_ptr말고 shared_ptr, unique_ptr을 사용해야 한다.
결과적으로 weak_ptr은 shared_ptr을 가리키는 일종의 임시 포인터라고 생각하면 된다.
shared_ptr가 어떤 상태이던지 weak_ptr은 그냥 가리킬 뿐이다.

- Callable (function 자료형)
()를 붙여서 호출 가능한 것을 C++에서는 Callable이라고 한다. (전에 보았던 Funtor와 비슷하다.)
class CallClass {
public:
	void operator()(int a, int b) { std::cout << "a + b = " << a + b << std::endl; }
};
위와 같이 생긴 녀석이 바로 Callable이다.
이유는 CallClass obj; obj(1, 2);와 같은 코드가 가능하기 때문이다.
auto CallFunc = [](int a, int b) { std::cout << "a + b = " << a + b << std::endl; }; 이 녀석도 Callable이다.
왜냐면 CallFunc(1, 2);이렇게 ()를 붙여서 호출이 가능하기 때문이다.
이러한 Callable을 객체 형태로 보관가능하게 해주는 것이 std::function이다.

간단한 사용법은 다음 예시를 보면 이해하기 쉽다.
-------------------------------------------------------------------------------------------------------------
void CallFunc(int a, int b) {
	cout << "a + b = " << a + b << endl;
}

class CallClass {
public:
	CallClass() {}
	void operator()(int a, int b) { cout << "a + b = " << a + b << endl; }
	int MemberFunc_1(const CallClass& var) { return 1; }
	void MemberFunc_2(int p) const { cout << "this is const function\n"; }
	short MemberFunc_3() { return 1; }
};

int main()
{
	function<void(int, int)> A = CallFunc;
	A(1, 2);

	function<void(int, int)> B = CallClass();
	B(3, 4);

	function<int(string&&)> C = [](string&& str)->int {cout << str << endl; return 1; };
	cout << C("Modern C++ Study") << "\n";

	CallClass tempClass;
	function<int(CallClass&, const CallClass&)> D = &CallClass::MemberFunc_1;
	D(tempClass, CallClass());

	function<void(const CallClass&, int)> E = &CallClass::MemberFunc_2;
	E(tempClass, 1);

	function<short(CallClass&)> F = &CallClass::MemberFunc_3;
	F(tempClass);
}
-------------------------------------------------------------------------------------------------------------
보통의 함수나 Functor는 { function<반환형(함수 인자들)> 함수객체이름 = 함수 or Functor or 람다 }와 같이 사용하면 된다.
멤버 함수는 { function<멤버 함수 반환형(멤버 함수를 가지고 있는 특정 객체 참조, 멤버 함수 인자들)> 함수객체이름 = 멤버 함수의 주소 }
클래스의 멤버 함수는 약간 다르게 돌아가는데 함수 인자들 외에 해당 객체의 참조를 인자로 받아야 한다.
그리고 해당 클래스 멤버 함수에 대한 주소를 받아야 하기에 &가 추가적으로 붙게 된다.

- bind 함수
함수 인자 중 하나를 정해주는 bind 함수가 존재한다.
placeholders라는 함수 인자 위치가 존재하는데 이를 이용하면 해당 인자 위치에는 함수 값을 넣을 수 있게 된다.

밑은 사용 예시다.
int add(int v, int w, int x, int y, int z) { return v + w + x + y + z; }
auto add_binded = std::bind(add, std::placeholders::_1, 7, std::placeholders::_2, 7, 7);
이경우 add_binded 함수는 add(사용자 지정 값, 7, 사용자 지정 값, 7, 7); 으로 인식되고 사용자 지정 값을 추려준다.
따라서 add_binded(0,1)은 0 + 7 + 1 + 7 + 7 이 되어 22라는 값이 도출된다.
이렇게 std::placeholders::는 사용자 지정 값을 넣을 수 있는 공간을 만들어주는 역할을 해주고 20번째까지 존재한다.

bind에 지정해주는 값은 복사되어서 전달되기에 참조를 사용하는 경우는 참조 인자라고 명시해주어야 한다. 밑은 이에 대한 예시이다.
void Swap(int& a, int& b) 
{ 
	int t = move(a); 
	a = move(b);
	b = move(t);
}
int a = 3, b = 7;
auto Swap_binded = std::bind(Swap, a, b); swap_binded();
위와 같은 상황에서 a와 b는 과연 바뀌었을까? 안바뀐다. bind에 전달된 값은 복사되어 들어가기 때문이다.
이렇게 auto Swap_binded = std::bind(Swap, std::ref(a), std::ref(b)); 참조라고 명시를 하면 바뀐다.

template <class T>
void Swap(T& a, T& b)
{ 
	T t = move(a);
	a = move(b);
	b = move(t);
}
auto Swap_binded = std::bind(Swap<int>, std::ref(a), std::ref(b));
만약 Swap함수가 위과 같은 템플릿 함수라면 그 형을 당연히 명시해주어야 한다.
그런데 이 템플릿 Swap 함수가 클래스 멤버 함수라면? function 자료형을 다루었던 방식을 생각해보면 된다.
class CSwap
{
public:
	template <class T>
	void Swap(T& a, T& b)
	{
		T t = move(a);
		a = move(b);
		b = move(t);
	}
};
CSwap swapClass;
auto Swap_binded = std::bind(&CSwap::Swap<int>, std::ref(swapClass), std::ref(a), std::ref(b));
Swap_binded();
이렇게 특정 클래스 객체를 따로 집어 넣어주면 된다.
그리고 const &인 경우는 std::cref()를 사용한다.

- 유니폼 초기화
class A {
 public:
  A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
  A a();
}
위 상황에서 "A 의 생성자 호출!" 이라는 문구가 과연 콘솔 창에 나올까? 안나온다.
a()는 컴파일러가 보기에 functor처럼 인식을 하여 생성자를 호출할 생각조차 하지 않는다.
그렇다면 A a{};는 어떨까? "A 의 생성자 호출!"가 콘솔 창에 출력이 된다.
{}를 사용하여 초기화하는 것을 균일한 초기화라고 한다.
균일한 초기화는 형이 조금이라도 다르면 명시적 형변환을 해주어야 한다.
A(int x) {}; A a(3.5); 이건 가능하지만 A a{3.5}; 이건 안된다. 물론 A a{(int)3.5}; 이건 가능하다.
명시적 형변환을 통해 아래와 같은 문구들이 편하게 사용가능하다.
std::map<std::string, int> var_map = { {"abc", 1}, {"hi", 3}, {"hello", 5}, {"c++", 2}, {"java", 6} };
std:vector<int> var_vec = { 1, 2, 3, 4, 5 };

- C++ 쓰레드
C++에서는 thread라는 자료형을 통해 쓰레딩을 사용한다.

단순한 예시를 들어보자
void func(int &p) { p++; return p; }
이러한 함수를 쓰레딩으로 돌리기 위해선 std::thread th_for_func = thread(func, std::ref(i)); 이렇게 사용한다.
아니면 std::thread th_for_func(func, std::ref(i)); 이렇게 생성자로 넣어준다.
std::bind 함수와 인자가 유사하다.
쓰레드를 생성하고 난 뒤에는 join() 함수를 통해 수행하게 된다. 위의 경우에서는 th_for_func.join() 이렇게 사용한다.
join()은 해당 쓰레드가 모두 끝나는 경우 return 된다.
join()과 다른 성격을 가진 녀석도 있는데 detach() 함수이다.
join()을 하면 어떤 프로그램이 수행되는 시간 내에 무조건 join()한 함수가 종료된다. (반대로 join()한 함수가 종료되지 않았다면 프로그램도 계속 돌아간다.)
detach()를 하면 프로그램의 동작이 끝났어도 백그라운드로 해당 함수들이 수행된다.
간단하게 main 함수가 동작을 중단해도 detach()로 수행한 쓰레드들은 알아서 동작한다.
thread에게 전달하는 함수의 반환값은 추후에 알 방법이 없기 때문에 특정 함수를 수행하고 난 뒤에 어떤 결과값을 받고 싶다면 void 형 함수의 인자에 포인터나 참조로 넘겨야 한다.

밑은 쓰레딩 연산 속도를 비교하기 위한 예제 코드다.
------------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

const int destin = 2100000000;
double result;
clock_t Start, End;

void func(int& s)
{
	for (int i = 0; i < destin; i++)
		s++;
}

void th_func(int& s) {
	int sum = 0;
	for (int i = 0; i < destin / 3; i++)
		sum++;
	s += sum;
}

int func_ret(int p) {
	return p;
}

int main()
{
	int sum = 0;
	Start = clock();
	func(sum);
	End = clock();
	result = (double)(End - Start) / 1e3;
	cout << "Sum Result : " << sum << '\n';
	cout << "Normal Func Time : " << result << "\n\n";

	sum -= destin;

	Start = clock();
	std::thread th_1 = thread(th_func, std::ref(sum));
	std::thread th_2 = thread(th_func, std::ref(sum));
	std::thread th_3(th_func, std::ref(sum));
	th_1.join();
	th_2.join();
	th_3.join();
	End = clock();
	result = (double)(End - Start) / 1e3;
	cout << "Sum Result : " << sum << '\n';
	cout << "Thread Func Time : " << result << '\n';
}
------------------------------------------------------------------------------------------------
위를 실행해보면 결과는 다음과 같다.
----------------------------
Sum Result : 2100000000
Normal Func Time : 1.414

Sum Result : 2100000000
Thread Func Time : 0.45
----------------------------
거의 3배 이상 속도 차이가 나는 것을 알 수 있다.

위의 예시는 쓰레드들이 같은 원소를 참조하여 발생하는 문제를 고려하지 않았다.
th_func에서는 int sum이라는 변수를 따로 두어서 여기에 더한 뒤에 최종 값은 s에 추가적으로 더해주는 것이기에 여기선 이러한 문제가 발생하지 않는다.
하지만 밑과 같이 구현된다면 어떻게 될까?
void th_func(int& s) {
	for (int i = 0; i < destin / 3; i++)
		s++;
}
이렇게 구현이 되면 문제가 발생한다.
각 쓰레드마다 공통된 변수 s를 동시에 접근해서 같이 더하면 한쪽은 더해지고 나머지 한쪽은 더해지지 않는 경우가 발생하기 때문이다.
이렇게 각기 다른 쓰레드가 같은 자원을 동시에 접근하는 것을 방지하기 위해 C++에 std::mutex가 존재한다.

먼저 임계구역 교통정리를 해주는 mutex를 선언한다.
그냥 변수 선언하듯이 std::mutex var; 이렇게 해주면 된다.
다른 쓰레드들이 건드리지 못하게 할 때는 lock()으로 잠금하고 다른 쓰레드들의 접근을 허용할 때는 unlock()을 사용하면 된다.
그렇다면 th_func를 mutex를 활용하여 제대로 바꾸려면 어떻게 해야할까?
void func_improved(int& s, std::mutex& mvar)
{
	mvar.lock();
	for (int i = 0; i < destin / 3; i++)
		s++;
	mvar.unlock();
}
이렇게 바꾸면 될까?
이렇게 바꾼다면 한개의 쓰레드가 for문을 돌리는 동안 공유 자원이 잠겨 다른 쓰레드들은 그냥 지켜만 봐야한다.
제대로 바꾼 함수는 다음과 같아야 한다.
void func_improved(int& s, std::mutex& mvar)
{
	mvar.lock();
	for (int i = 0; i < destin / 3; i++)
		s++;
	mvar.unlock();
}
꼭 unlock()을 해주어야 한다는 점이 프로그래머에게 위험할 수 있다.
따라서 다음과 같은 std::lock_guard<std::mutex> lock()이 등장했다.
블록 내에서 선언된 다음과 같은 임계구역 잠금 변수는 선언시에 lock()을 걸며 블록을 빠져나오면서 자동으로 unlock()을 해준다.
바꾼 함수는 다음과 같다.
void func_improved(int& s, std::mutex& mvar)
{
	for (int i = 0; i < destin / 3; i++) {
		std::lock_guard<std::mutex> lock(mvar);
		s++; 
	}
}
mutex에는 데드락을 방지하기 위해 try_lock()이라는 함수도 제공한다. 해당 mutex의 lock()을 일단 시도하고 lock()이 성공한다면 true를 반환하고 실패한다면 false를 반환한다.
밑과 같이 보통 쓰인다.
void func_1(std::mutex& m1, std::mutex& m2) {
  for (int i = 0; i < 10; i++) {
    m1.lock();
    m2.lock();

	// 어떤 작업

    m2.unlock();
    m1.unlock();
  }
}

void func_2(std::mutex& m1, std::mutex& m2) {
  for (int i = 0; i < 10; i++) {
    while (true) {
      m2.lock();

      if (!m1.try_lock()) {
        m2.unlock();
        continue;
      }

      // 어떤 작업
	  
      m1.unlock();
      m2.unlock();
      break;
    }
  }
}
func_1은 보통의 방식대로 lock(), unlock()만 해주지만 func_2는 같은 방식으로 구현했다가 데드락이 걸려버릴 것이다.
따라서 func_2는 m1과 m2가 모두 lock()될 수 있는 상황을 만날 때 까지 계속 기다리도록 구현해야 한다.

##################### 쓰레드 더 진행해야 함 #####################

##################### 쓰레드 더 진행해야 함 #####################

- <random> 라이브러리
c의 난수 생성보다 효과적으로, 즉 더 랜덤하게 난수를 생성해주는 random 라이브러리가 c++에 있다. (따라서 기존 rand() 방식은 c++에서는 버리자!)
예시는 밑과 같다.
#include <iostream>
#include <random>

int main() {
  // 시드값을 얻기 위한 random_device 생성.
  std::random_device rd;

  // random_device 를 통해 난수 생성 엔진을 초기화 한다.
  std::mt19937 gen(rd());

  // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의.
  std::uniform_int_distribution<int> dis(0, 99);

  for (int i = 0; i < 5; i++) {
    std::cout << "난수 : " << dis(gen) << std::endl;
  }
}
사용법은 예시를 보면 알겠지만 난수 기기를 생성 -> 기기를 이용해 난수 엔진 초기화 -> 균등 분포 정의 -> 난수 획득 순서로 이어진다.
실제 컴퓨터 신호에 따른 난수를 생성해내는 것이기에 rand()와 같은 의사 난수 방식보다는 속도가 느리다.
mt19937라는 자료형은 난수 생성 엔진으로 메르센 트위스터라는 알고리즘을 이용한다고 한다...(이 보다 난수의 질은 좀 떨어지지만 메모리를 덜 먹는 minstd_rand 엔진도 있다.)
보통은 그냥 mt19937를 사용하는 엔진을 만들어 쓰는 것이 편하다.
std::mt19937 gen(rd()); 여기서 rd() 대신에 특정 시드값을 std::mt19937 gen(123); 이렇게 박아 넣어도 된다. (당연히 시드가 같기 때문에 )
위에선 균등 난수열을 생성하기 위해서 uniform_int_distribution를 사용했지만 <random>에는 다른 분포 유형도 많이 있다. (normal_distribution: 정규 분포 등...)

- <chrono> 라이브러리
기존 c에서 쓰던 clock 함수와 비슷하지만 좀 더 정밀하다.
사용법은 다음과 같다.
std::chrono::time_point<std::chrono::high_resolution_clock> start = std::chrono::high_resolution_clock::now(); // 시작 시각 체크
std::chrono::time_point<std::chrono::high_resolution_clock> end = std::chrono::high_resolution_clock::now(); // 끝 시각 체크
auto result = end - start;
이러한 코드에서 result.count()를 하면 몇 틱(tick)이 걸렸는지를 알 수가 있다.
틱에 대한 단위는 컴퓨터마다 다를 수 있기 때문에 실제 걸린 시간을 알기 위해서는 std::chrono::duration_cast<std::chrono::microseconds>(result).count()를 해주면 된다.
여기서는 std::chrono::microseconds인 ms(0.000001s) 단위를 사용했지만 std::chrono::seconds로 초 단위를 구할 수도 있고 다른 시각 단위도 많다.

현재 시간을 출력하는 방법은 c의 time_t 구조체를 병행하여 사용하게 된다.
auto now = std::chrono::system_clock::now();
std::time_t t = std::chrono::system_clock::to_time_t(now);
cout << std::put_time(std::localtime(&t), "%F %T %z");
C++20에서는 다음과 같이 더 간단해졌다. c의 time_t 구조체, localtime 함수를 사용할 필요도 없어 depricated 경고를 피할 수 있다.
auto local = std::chrono::zoned_time{ std::chrono::current_zone(), std::chrono::system_clock::now() };
cout << local;

- <filesystem> 라이브러리
사용법은 밑과 같다.
std::filesystem::path p("./some_file"); // 현재 프로젝트 폴더 공간에서 some_file이라는 폴더 혹은 파일이 있는지를 찾아보려 한다.
std::filesystem::exists(p) // some_file이라는 폴더 혹은 파일의 존재 유무를 boolean형으로 알려준다.
std::filesystem::is_regular_file(p) // some_file이라는 것이 파일인지 아닌지 여부를 boolean형으로 알려준다.
std::filesystem::is_directory(p) // some_file이라는 것이 폴더인지 아닌지 여부를 boolean형으로 알려준다.

경로 지정 방식에 관한 함수는 다음과 같다.
filesystem::path p("./some_file.txt");
해당 선언이 이루어진 상태를 가정해보자.
filesystem::current_path(); // 얘는 현재 경로를 알려준다.
p.relative_path() // 얘는 ./some_file.txt에 대한 상대 경로를 알려준다.
filesystem::absolute(p) // 얘는 ./some_file.txt에 대한 절대 경로를 알려준다.
filesystem::canonical(p) // 얘는 ./some_file.txt에 대한 공식적인 절대 경로를 알려준다. 앵간하면 absolute() 얘말고 canonical()이 녀석을 쓰자.

특정 디렉토리 안의 파일 순회는 다음과 같다.
filesystem::directory_iterator itr(filesystem::current_path() / "gyungjun");
while (itr != filesystem::end(itr)) 
{
    const filesystem::directory_entry& entry = *itr;
    entry.path(); // 얘가 경로를 포함한 파일 이름을 가지고 있다.
    itr++;
}
위 코드에서 filesystem::current_path() / "gyungjun" 이 녀석이 특이할 수 있는데 operator / 를 지원해서 현재 폴더 아래의 /gyungjun 폴더에서 탐색을 진행하게 된다.
즉 예를 들어 현재 current_path가 C:// 라면 filesystem::current_path() / "gyungjun"는 C://gyungjun// 이게 되는 것이다.
위 코드를 ranged for문을 이용하여 좀 더 줄여보면 아래와 같다.
for (const filesystem::directory_entry& entry : filesystem::directory_iterator(filesystem::current_path() / "gyungjun")) 
{
    std::cout << entry.path() << std::endl;
}
위와 같은 순회 방식은 폴더 내의 폴더가 있는 경우 재귀적으로 순회를 하지 않는다. 그냥 폴더 이름을 바로 알려줄 뿐이다.
따라서 재귀적으로 순회하는 방식은 다음과 같이 recursive_directory_iterator를 이용해야 한다.
for (const filesystem::directory_entry& entry : filesystem::recursive_directory_iterator(filesystem::current_path() / "gyungjun")) 
{
    std::cout << entry.path() << std::endl;
}

이러한 directory_iterator들은 주의해야 할 점이 있는데 파일, 디렉토리가 삭제되는 경우 이 iterator의 순번 구조도 바뀐다는 것이다.
따라서 순회하면서 특정 파일, 디렉토리를 삭제하려면 iterator를 초기화하고 다시 받으면서 진행해줘야 한다.
이러한 로직은 보통 다음과 같이 이중 반복문의 형태를 취할 것이다.
while (true) 
{
	bool is_modified = false;
    for (const auto& entry : filesystem::directory_iterator("./gyungjun")) 
	{
		const std::wstring ext = entry.path().extension();
		if (ext == L".txt") 
		{
			filesystem::remove(entry.path());
			is_modified = true;
			break;
		}
    }
    if (!is_modified) 
      break;
}
위 코드와 같이 파일 구조가 변경되었다면 반복문을 탈출하고 iterator 정의 후 다시 들어가야 한다.

std::ofstream에서는 폴더를 직접 만들지 못한다. 특정 확장자를 가진 파일만을 만들어 줄 뿐이다.
따라서 std::filesystem에서는 폴더를 만드는 함수를 제공하는데 다음과 같이 간단하다.
filesystem::path p("./gyungjun/research");
filesystem::create_directory(p);
위의 코드를 실행하면 현재 경로의 gyungjun 폴더 내부의 research 폴더를 생성해준다.
그런데 만약에 현재 경로에 gyungjun 폴더가 없었다면 create_directory() 함수가 현재 경로에 gyunjun 폴더를 생성하고 그 내부의 research 폴더도 생성할까?
이 경우엔 에러가 출력된다.
이렇게 한번에 여러 개의 폴더를 한번에 만드는 경우는 create_directory(p) 함수 대신에 create_directories(p)를 사용하면 된다.

파일을 복사하는 방법은 다음과 같다.
filesystem::path from("./fromDir");
filesystem::path to("./toDir");
filesystem::copy(from, to, filesystem::copy_options::recursive);
이렇게 수행하면 옵션이 recursive이기 때문에 fromDir의 내용을 재귀적으로 toDir에 복사하여 넣게 된다.
그냥 filesystem::copy(from, to);를 하게 된다면 그냥 fromDir에 있는 파일들만 복사하게 된다.
주의점은 이미 있는 파일을 덮어씌우려는 경우는 실제로 덮어씌우지 않고 예외를 던진다.
따라서 skip_existing(이미 존재하는 거 제외), overwrite_existing(이미 존재하는 파일 덮어씌움), update_existing(이미 존재하는 파일이 더 오래된 경우 덮어씌움) 이러한 옵션을 잘 이용해야 한다.

파일을 삭제하는 법도 간단하다.
filesystem::path f("./gyungjun.txt");
filesystem::remove(p);
이를 수행하면 gyungjun.txt이 삭제된다. 빈 디렉토리도 삭제가능하다.
내용물이 담긴 디렉토리를 삭제하고 싶다면 remove_all(filesystem::path("./gyungjun"));을 이용한다.

- std::optional<>
어떤 객체는 있을 수도 있고 없을 수도 있다. 객체가 없는 경우는 디폴트 객체를 정의해서 사용할 수 있다.
다음과 같은 예시의 경우이다.
class Person
{
	string m_Name;
public:
	Person(string Name = "") { m_Name = Name; }
	string& GetName() { return m_Name; }
};

Person FindPerson(vector<Person>&List, string Name)
{
	for (auto& p : List) {
		if (p.GetName() == Name) {
			return p;
		}
	}
	return Person();
}
FindPerson은 이름이 같은 사람을 찾아 반환해주는 함수이다.
이 함수는 얼핏보면 동작을 잘하는 듯 하지만 문제가 2가지 있다.
이름이 없는 사람, 즉 m_Name == "" 인 사람이 실제로 존재한다면? 해당 함수의 반환형을 받아서 이게 List에서 찾은 사람인지 아니면 없는데 기본 객체로 반환된 녀석인지 알 수 있을까?
찾는 사람이 없는 경우 Person()과 같이 기본 객체를 반환하는데 여기선 예시를 Person 객체로 하였지만 실제 기본 객체를 만드는데 시간이 많이 드는 클래스 였다면? 이게 과연 효율적일까?
이러한 두 가지 경우를 모두 해결해 줄 수 있는 것이 std::optional<>이다.
해당 함수를 std::optional<>을 사용하여 2가지 문제를 해결해보면 다음과 같다.
std::optional<Person> FindPerson(vector<Person>&List, string Name)
{
	for (auto& p : List) {
		if (p.GetName() == Name) {
			return p;
		}
	}
	return std::nullopt;
}
std::optional<> 형이 기본적으로 가지고 있는 nullopt를 이용하면 해결이 가능하다.
if (!FindPerson(person_list, "").has_value()) 
{
		cout << "매칭되는 사람이 진짜 없다.";
}
이렇게 has_value()로 진짜 값을 가지는지 아닌지를 식별할 수 있다.
사실 optional에는 boolean형에 대한 오퍼레이터가 정의되어 있기 때문에 FindPerson(person_list, "").has_value() 대신에 FindPerson(person_list, "")이를 사용해도 된다.

optional의 단점으로는 type이 레퍼런스가 되는 경우에 약간 복잡해진다는 것이다.
Person me("gyungjun");
std::optional<std::reference_wrapper<Person>> maybe_Person = std::ref(me);
이렇게 optinal의 레퍼런스 참조는 타입은 reference_wrapper를 이용하고 실제로 담는 변수는 ref를 이용한다.
실제 값을 얻는 경우는 스마트포인터와 같이 maybe_Person->get()을 사용하면 된다. 

- std::variant<>
union과 같이 다양한 형을 담을 수 있다. union과 다른 점은 실제 union은 어떤 자료형을 담고 있는지 파악하기 어렵다는 것이고 variant는 이러한 위험을 방시할 수 있다.
일단 variant<>에 아무런 값이 없이 초기화된다하면 제일 처음에 적힌 자료형의 기본 생성자가 호출된다.
std::variant<int, std::string, double> v; 이 경우에는 variant는 int형을 취하며 그 int에는 0이 들어가 있는 상태이다.
variant의 크기는 가장 큰 변수의 크기를 따라간다. 위의 경우에서는 int, std::string, double 이들 중 가장 큰 크기의 자료형을 따라간다.
variant 함수들은 다음과 같은 것이 있다.
std::variant<int, std::string, double> v;
v.index(); // 현재 몇 번째 타입이 사용되고 있는지 알 수 있다. 0이면 int가 사용되는 것이다.
v.index()가 0이라면 실제 값은 get<int>(v) 이렇게 하거나 get<0>(v) 이렇게 할 수 있다. 

값이 들어있지 않은 상태의 variant는 올바른 값이 삽입되지 않은 변수다. 따라서 보통의 경우 선언하고 특정 값으로 초기화를 바로 하게 된다.
하지만 monostate라는 값을 이용하면 마치 std::variant를 std::optinal과 같이 사용할 수 있다.
std::variant<std::monostate, int, std::string> v; 이 경우는 선언과 동시에 변수 v는 monostate라는 형태로 설정이 된다.
위의 경우 v.index()가 0인 경우 v가 아무런 값도 가지지 않았다는 것을 인지할 수 있다.

이러한 std::variant<>는 db에서 값을 뽑아오는 경우 보통 사용된다. 테이블 안에 들어있는 자료형은 보통 한 종류가 아니기 때문이다. 

- structured binding
알고리즘 풀 때 많이 사용했던 자료형은 std::tuple<>이다. 보통 빠르게 구현해야 되고 구조체를 만들기 귀찮기 때문이다.
리마인딩 해보면 tuple<int, string, double> k = { 1, "이경준", 1.0 }; 이렇게 선언 및 초기화가 가능하다.
사용시에는 int k1 = get<0>(k); string k2 = get<1>(k); double k3 = get<2>(k); 이렇게하면 된다.
c++17 이후에는 더 간단해져서 auto [k1, k2, k3] = k; 이렇게 끝난다. 이를 structured binding이라고 한다.
tuple에만 사용이 가능한 것이 아니라 모든 구조체 밑 클래스, std::pair 등 값이 묶여 있는 구조에 사용이 가능하다. (클래스는 멤버 변수가 public인 경우에만...)
활용 예시를 좀 더 보자면 밑과 같이 반복문도 깔끔하게 구현이 가능하다.
std::map<int, std::string> m = {{3, "hi"}, {5, "hello"}};
for (auto& [key, val] : m) 
{
	std::cout << "Key : " << key << " value : " << val << std::endl;
}

- C++ 가변인자 (<cstdarg> 라이브러리)
특정 함수는 가변인자를 사용할 수 있다.
예를 들어 C의 printf()함수는 printf("내 나이: %d, 내 이름: %s", 25, "gyungjunlee"); 이렇게 인자가 자유자재이고 형태도 각양각색이다.
이러한 함수를 구현하려면 가변인자를 사용해야 한다.
가변인자에 필요한 요소는 3가지가 존재한다.

va_list : 가변인자를 담을 자료형이 필요한데 이 녀석이 그 역할을 수행한다.
자료형이기에 std::va_list variadic_list; 이렇게 선언해주면 된다.

__va_start : va_list가 가변인자들을 담는 리스트 자료형이라고 했는데 이 리스트를 초기화하기 위해서는 인자들의 시작점을 알아야 한다. 그 시작점을 넘겨주기 위한 함수다.
시작점을 알려주기 위해서 va_list의 주소와 시작 변수 이름을 넣어준다. 예를 들어 사용법은 밑과 같다.
void valist_sample(int u, ...)
{
	va_list variadic_list;
	__va_start(&variadic_list, u);
	/*특정 작업*/
	va_end(variadic_list);
}
u를 va_list의 시작점으로 설정하려면 위와 같이 __va_start(&variadic_list, u); 이렇게 사용하게 된다.
함수의 인자 형태를 보면 (int u, ...) 이러한 형태를 취하고 있는데 가변인자를 사용한다는 의미로 ...을 사용한다.
가변 인자들의 개수를 미리 알 수 있는 방법이 없기에 가변인자를 사용하는 함수들은 반드시 가변인자의 개수라던지 %s, %d와 같은 힌트를 넘겨야 한다.
printf()함수도 보면 처음 인자에 예로 my name is %s, age is %d 이러한 문자열을 넘기게 되는데 %s와 %d와 같은 특정 패턴의 개수를 내부적으로 카운트할 것이다.

va_end : va_end는 va_list 자료형의 해제를 진행한다. va_list 자료형은 내부적으로 동적할당이 되어 있는 C스타일의 자료형으로 va_end(variadic_list); 이렇게 따로 해제를 해주어야 한다.

va_arg : va_list에서 원소를 하나 처리하는 매크로 함수이다. 사용법은 다음과 같다. 만약 꺼낼 녀석이 문자열이라면 va_arg(va, char *)를 사용해 va에서 원소 char *를 꺼내면서 주소를 다음 원소로 옮긴다.
따라서 주어지는 데이터형의 크기가 중요하다. va_arg(va, int), va_arg(va, double) .. 이렇게 자료형에 따라 다음 주소로 이동하는 보폭이 달라지기 때문에 주어진 가변인자와 매칭되는 정확한 가변인자를 넘겨주어야 한다.
예를 들어 printf("my name is %s", 1); 이렇게 하면 안된다는 것이다.
va_arg의 치명적인 단점이 있는데 C에서 지원하는 int, char, float 등 이러한 기본적인 자료형에 대해서만 사용이 가능하다는 것이다.
va_arg(va, std::string); va_arg(va, std::variant<double, float>); 이런 것들 모두 안된다...

밑에는 해당 va_list를 사용하여 만들어본 printf 함수이다.
void printf_cplus(const std::string& str, ...)
{
	std::vector<std::pair<int, int>> replace_list;
	std::vector<std::string> replace_pattern{ "%s", "%c", "%d", "%u", "%f" };
	int pos, pat_Index, shift = 0;
	for (int i = 0; i < replace_pattern.size(); i++) {
		pos = 0;
		while ((pat_Index = str.find(replace_pattern[i], pos)) != std::string::npos) {
			replace_list.push_back({ pat_Index, i });
			pos += pat_Index + replace_pattern[i].length();
		}

	}
	std::va_list va;
	std::sort(replace_list.begin(), replace_list.end());
	__va_start(&va, str);
	std::string pattern, result = str;
	for (const auto& element : replace_list) {
		switch (element.second) {
		case 0:
			pattern = va_arg(va, char *);
			break;
		case 1:
			pattern += va_arg(va, char);
			break;
		case 2:
			pattern = to_string(va_arg(va, int));
			break;
		case 3:
			pattern = to_string(va_arg(va, unsigned int));
			break;
		case 4:
			pattern = to_string(va_arg(va, double));
			break;
		default:
			break;
		}
		result.replace(element.first + shift, replace_pattern[element.second].length(), pattern);
		shift += pattern.length() - replace_pattern[element.second].length();
	}
	va_end(va);
	cout << result;
}
기본적으로 처음에 주어진 %s, %d와 같은 패턴의 개수들을 세고 해당 개수들을 세면서 어떤 자료형인지, 어디 위치를 교체해야 하는지도 저장한다.
해당 저장된 배열을 통해 순회하면서 스트링을 교체해준다.

그렇다면 %s, %d 등의 키워드로 문자열을 바꾸어 반환해주는 함수 format_cplus를 만들어보면 밑과 같다.
std::string format_cplus(const std::string&& str, ...) {
	va_list va;
	__va_start(&va, str);
	int len = vsnprintf(nullptr, 0, str.c_str(), va);
	if (len <= 0) return "";
	char* buf = new char[len + 1];
	vsnprintf(buf, static_cast<size_t>(len) + 1, str.c_str(), va);
	va_end(va);
	string str_ret = buf;
	delete[]buf;
	return str_ret;
}
생소할 수 있는 함수가 섞여 있는데 vsnprintf() 함수이다. 해당 함수 이름을 뜯어 보면 앞에 v가 붙는데 이는 va_list를 인자로 받는 함수라는 의미를 내포한다.
그 다음 v를 제외한 snprintf() 함수는 버퍼에 printf() 함수의 기능을 수행한다. 즉 동적 할당된 char *를 넣어주면 해당 공간에 printf()의 결과 값을 담아서 반환해준다.
결과적으로 vsnprintf()는 va_list를 인자로 받는 버퍼 반환 printf() 함수다.
해당 함수에서 %s, %d 등의 키워드들은 모두 처리해주고 나머지는 대부분 va_list 초기화 밑 해제 함수와 관련있다. (앞서 구현했던 printf_cplus 함수도 vsnprintf()를 이용하면 매우 간단해진다.)
va_list의 문제는 char*, char, int와 같은 기본 자료형만을 다룰 수 있다.
C++에서는 va_arg의 기본 자료형 밖에 사용하지 못한다는 것과 va_list의 크기를 미리 알지 못한다는 단점을 해결할 수 있는 방법이 존재한다.

- 템플릿 가변인자
말그대로 템플릿을 사용하여 가변인자를 이용하는 방식으로 C++11부터 지원한다.

기본 템플릿 함수는 다음과 같이 생겼다.
template <typename T>
void func(T arg) {
  /*어떤 작업*/
}

템플릿 가변인자 함수는 다음과 같다.
template <typename T, typename... Types>
void func(T arg, Types... args) {
  /*어떤 작업*/
}

두 개를 비교해보면 처음보는 typename... Types 이러한 녀석이 가변인자의 역할을 한다.
이 녀석을 정확한 말로 템플릿 파라미터 팩이라고 한다.
함수에서는 Types... args 이렇게 사용된다.
파이썬의 print()함수는 print(1, "string", 1.3); 이렇게 선언하면 1 string 1.3 이렇게 주어진 인자들을 모두 출력이 가능하다.
기존의 va_list에서는 주어진 가변 인자의 개수를 미리 알 수가 없기에 불가능한 표현이지만 템플릿 가변인자 함수에서는 가능하다.
구현은 다음과 같다.

template <typename T>
void print(T arg) {
  std::cout << arg << std::endl;
}

template <typename T, typename... Types>
void print(T arg, Types... args) {
  std::cout << arg << " ";
  print(args...);
}

이렇게 구현하면 파이썬의 print 함수와 동일하게 작동한다.
원리는 다음과 같다. void print(T arg, Types... args) 해당 함수에서 인자들을 하나 읽어 사용하고 나머지 인자들은 print(args...) 이렇게 다음 함수로 넘긴다.
재귀적으로 작동하는 것이다.
재귀적으로 작동하다가 인자가 하나만 남은 경우에는 컴파일러가 print(T arg, Types... args) 이 녀석과 print(T arg) 이 녀석을 비교하고 print(T arg) 얘를 선택하게 된다.
함수 선언 순서도 중요한데 print(T arg, Types... args) 이 녀석 내부에서 print(T arg) 이 녀석을 쓰는 경우가 생기기 때문에 선언 순서는 위와 같아야 한다.

가변 템플릿 인자에서는 sizeof...() 함수를 제공하는데 이를 통해 미리 가변인자가 몇 개인지 알 수 있다.

template <typename... Ts>
int print_num(Ts... n) {
	return sizeof...(n);
}
해당함수를 선언하고 print_num(1, "hello", 2.1, "hi", 3); 이렇게 실행 해주면 반환값 5가 획득될 것이다.

템플릿 가변인자를 사용하면 거의 대부분의 경우는 재귀 호출을 사용하기 때문에 마지막 마무리 함수를 잘 짜주어야 한다.
얘를 들어 다음과 같은 주어진 숫자를 모두 더하는 함수 예시를 보자.
template <typename T>
T sum_all(T k) { return k; }

template <typename T, typename... Ints>
T sum_all(T num, Ints... nums) {
	return num + sum_all(nums...);
}
여기서 T sum_all(T k) 함수가 없으면 sum_all의 마무리를 지을 수가 없기에 에러가 난다.

위 함수를 더 효과적으로 적을 수 있는데 C++17에서는 fold 기법을 제공한다.
위의 sum_all 함수는 밑과 같이 적을 수가 있다.
template <typename... Ints>
int sum_all(Ints... nums) {
	return (nums + ...);
}

위와 같이 num + sum_all(nums...) -> (nums + ...) 이러한 변환만 가능한 것이 아니라 sum_all(nums...) + num -> (... + nums) 이러한 표현도 가능하다.
만약 sum_all(1,2,3,4); 이렇게 사용이 되었다면 (nums + ...) 해당 경우엔 1 + (2 + (3 + 4)) 이러한 순서로 연산이 진행된다.

template <typename T, typename... Ints>
int sum_all(T number, Ints... nums) {
	return (number + ... + nums);
}
위와 같은 fold 표현도 가능하다.
해당 함수가 만약 sum_all(10, 11, 12, 13); 이렇게 사용되었다면 ((10 + 11) + 12) + 13 이와 같은 순서로 연산이 된다.
(nums + ... + number) 이렇게 반대로 할 수도 있다. 이 경우엔 11 + (12 + (13 + 10)) 이와 같은 순서로 연산이 된다.

fold 표현에서는 ',' 표현도 가능하다.
예시는 다음과 같다.
template <typename T, typename... Ints>
void push_backs(T& arys, Ints... contents) {
	(arys.push_back(contents), ...);
}
위 코드는 push_back() 함수를 확장한 코드로 string str; push_backs(str, 'h', 'e', 'l', 'l', 'o');
이렇게 하면 string str = "hello"; 와 같은 효과를 지닌다. 
이처럼 ','는 파라메터 팩에 앞서 나온 식을 모두 수행시키는 효과를 지닌다.

위에서 두 개의 함수로 쪼개져 있던 print() 템플릿 함수를 fold 기법과 람다를 통해 하나로 줄이면 다음과 같다.
template <typename... Types>
void print(Types&&... args) {
	([&]()->void { cout << args << ' '; }(), ...);
	cout << '\b';
}
한가지 유의사항이 있는데 fold 기법은 항상 ( ) 괄호 내부에 정의되어야 한다.

템플릿 파라메터를 이용한 format_cplus 함수는 다음과 같다.
template <typename... Types>
std::string format_cplus(const std::string&& str, Types&&...args)
{
	int len = snprintf(nullptr, 0, str.c_str(), args...);
	if (len <= 0) return "";
	char* buf = new char[len + 1];
	snprintf(buf, static_cast<size_t>(len) + 1, str.c_str(), args...);
	string str_ret = buf;
	delete[]buf;
	return str_ret;
}
이로써 C++에서 가변인자를 다루는 방법을 알아보았다.

- <regex> 라이브러리
문자열을 탐색할 때 매우 강력한 힘을 내는 정규식을 C++11부터 지원한다.
C++20에 와서도 정규식 재귀 패턴을 지원하지는 않지만 그것 외에는 모두 지원하기에 쓸만하다.
std::regex re(".*\.txt"); 이렇게 선언이 가능하고 다음 정규식은 보통 확장자가 txt인 파일을 찾을 때 사용될 것이다.
정규식 엔진도 std::regex re(".*\.txt", std::regex::grep); std::regex re(".*\.txt", std::regex::grep | std::regex::icase);과 같이 바꾸어 줄 수 있다.
이러한 옵션 외에도 최적화를 통해 정규식 탐색 속도를 올려주는 std::regex::optmize 옵션도 존재한다.
regex 관련 함수는 다음과 같다.

regex_match(/*문자열*/str, /*정규식*/re); // 주어진 문자열과 정규식이 정확히 맞아 떨어지는지 검사한다. 모든 문자열이 정규식 패턴과 일치해야 한다.
예를 들어 regex_match("temp.txt", std::regex(".*\.txt")); 이 녀석은 true가 나오지만 regex_match("temp.txt is there!", std::regex(".*\.txt")); 이 녀석은 false가 나온다.
매칭된 부분을 모두 가져올 수도 있는데 이 경우에 std::smatch라는 자료형을 이용한다.
예시는 다음과 같다.
std::regex R("(.*)\.txt");
vector<std::string> files{ "temp.txt", "this.pdf", "power.png", "kbs.txt", "mbc.gif", "pokemon.txt", "tv.pdf"};
std::smatch matchs;
for (auto& file : files) {
	if (regex_match(file, matchs, R)) {
		for (auto& match : matchs) {
			cout << match.str() << ' ';
		}
		cout << '\n';
	}
}
예시에서 중요히 봐야하는 것은 R("(.*)\.txt") 이 부분이다. .*를 괄호로 감싸고 있는데 이렇게 감싼 부분에 대한 정보가 모아져 따로 matchs에 들어가게 된다.
예를 들어 regex_match("temp.txt", matchs, R)'; 이를 수행하면 matchs에는 temp.txt, temp가 순서대로 담기게 된다.
첫번째에는 무조건 매칭된 전체 문자열이 들어가고 두번째 부터 앞서 나온 괄호에 감싸져 매칭된 부분(여기선 (.*)가 된다.)에 대한 문자열만 들어가게 된다.

regex_search(/*문자열*/str, /*정규식*/re); // 주어진 문자열에서 정규식에 해당하는 패턴이 있는지 검사한다. 정확히 맞아 떨어지지 않아도 부분적으로 매칭되면 true를 반환한다.
예를 들어 regex_search("temp.txt", regex("txt")); 이렇게 해도 txt가 매칭되기에 true를 반환한다.
regex_match와 똑같이 regex_search도 std::smatch를 이용하여 매칭되는 문자열을 담을 수 있다.
예시는 다음과 같다.
std::regex R(" ");
string files = "temp.txt this.pdf power.png kbs.txt mbc.gif pokemon.txt tv.pdf";
std::smatch match;
while (regex_search(files, match, R)) {
	cout << match.prefix() << '\n';
	files = match.suffix();
}
cout << files;
해당 코드를 실행하면 files의 내용이 공백 단위로 끊겨서 줄을 바꾸며 출력된다. 즉 토큰으로 끊는 작업을 하는 것이다.
주의할 점은 마지막에만 cout << 다음에 files가 왔다는 것이다.
이렇게 한 이유를 알기위해 먼저 smatch의 prefix()와 suffix()가 무엇인지를 먼저 알아야 한다.
regex_search("temp.txt this.pdf", match, regex(" "));를 수행하면 match에 매칭된 정보가 저장되게 된다.
일단 처음으로 매칭된 정보인 " " 공백이 match[0]에 저장이 된다.
추가적으로 prefix, suffix라는 정보도 저장이 되는데 prefix는 매칭된 부분의 앞에 나오는 내용이 모두 담기고 suffix 매칭된 부분의 뒤에 나오는 내용이 모두 담긴다.
"temp.txt this.pdf" 여기서는 공백이 매칭이 되었기에 공백 전인 "temp.txt" 이 녀석이 prefix가 되고 공백 후인 "this.pdf" 이 녀석이 suffix가 된다.
다시 예시 코드로 넘어가보면 처음 regex_search()가 수행되면 match의 상태는 다음과 같다. 
match[0] = " ", prefix = "temp.txt", suffix = "this.pdf power.png kbs.txt mbc.gif pokemon.txt tv.pdf"
계속해서 prefix에 파일 이름만 담기게 하기 위해서 files를 suffix로 바꿔주면서 반복문을 수행하는 것이다.
계속 반복문이 진행되다 보면 regex_search() 함수가 false를 반환하게 될 것이고 match에는 아무런 내용도 담기지 않을 것이다.
따라서 마지막 남은 파일 이름은 마지막 suffix인 files에 담기게 되고 마지막 출력을 cout << files;로 적게 된 것이다.
이런 방식 말고 std::sregex_iterator를 사용할 수도 있다.
위의 예시 코드를 std::sregex_iterator를 사용하여 바꾸면 다음과 같다.
std::regex R(" ");
string files = "temp.txt this.pdf power.png kbs.txt mbc.gif pokemon.txt tv.pdf";
std::sregex_iterator start(files.begin(), files.end(), R), back; // auto start = std::sregex_iterator(files.begin(), files.end(), R); 도 가능
auto end = std::sregex_iterator();
while (start != end) {
	cout << start->prefix() << '\n';
	back = start++;
}
cout << back->suffix() << '\n';
std::smatch는 사용하지 않고 std::sregex_iterator 내부에 prefix와 suffix에 대한 정보가 있다.

std::regex_replace(/*치환하고자 하는 대상 문자열*/target_str, /*정규식*/re, /*어떤 걸로 치환할 건지*/pattern); // 대상 문자열에서 정규식 패턴에 맞는 부분을 특정 문자열로 교체한다.
기존 regex 함수들은 반환형이 boolean이였지만 이 녀석은 치환 완료된 문자열을 반환한다.
예시는 다음과 같다.
std::regex R("%s");
string target = "my name is %s";
string result = regex_replace(target, R, "gyungjunlee");
cout << result;
%s 부분이 gyungjunlee로 교체되었다.

- 파일 입출력
c++에서 파일 입출력은 fstream을 통해 이루어진다. in, out 모두 fstream 하나로 가능하기 때문에 in만 되는 ifstream, out만 되는 ofstream을 사용하지 말고 fstream하나로 통합해서 사용하는 것이 권장된다.

파일 읽기는 다음과 같다.
std::fstream rfile("something.txt");
해당 파일이 열렸는지 아닌지는 rfile.is_open() 이라는 bool형 반환을 통해 알 수 있다.
열었다 닫았다는 다음과 같이 한다.
rfile.close(); // 닫기
rfile.open("something.txt"); // 읽기
파일 읽기 모드도 지정할 수 있다.
이진파일을 읽는 경우는 다음과 같다.
std::fstream rfile("something.txt", std::ios::binary);
이진 파일을 읽는 경우는 다음과 같이 크기를 지정하여 읽을 수 있다.
rfile.read((char*)(&x), 원하는 크기); read()함수의 첫 인자는 void형이기에 x는 원하는 데이터 형을 넣으면 된다. 바이트 단위로 읽기에 보통 char*를 사용한다.
