- Windows 10 이상에서 VS Code와 함께 CMake를 사용하는 법

# 초반 설치

1. Microsoft Store에 들어가서 Windows Terminal을 설치해준다.

2. Windows Terminal에서 PowerShell 탭을 열고 $PSVersionTable 명령어를 수행한 뒤에 출력된 PSVersion이 3 이상인지 확인한다. (3이하라면 PowerShell을 업데이트해준다. PowerShell 업데이트 방법은 알아서 찾아라...)

3. .NET Framework 4.5 버전 이상이 설치되어 있는지 확인한다. (Visual Studio에서 ".NET 테스크톱 개발" 항목을 선택하면 알아서 최신버전의 .NET Framework를 설치해준다.)

4. Windows Terminal을 관리자 모드로 열고 PowerShell 탭을 띄운후에 Get-ExecutionPolicy 명령어를 수행 후에 Restricted인지 확인한다. Restricted이라면 Set-ExecutionPolicy AllSigned 명령어를 추가적으로 수행해준다.

5. Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 명령어를 수행해 Chocolatey를 설치해준다.

6. 설치가 끝났으면 Windows Terminal를 관리자 모드로 재시작해주고 PowerShell 탭을 띄우고 choco 명령어를 수행해 Chocolatey가 잘 설치되었는지 확인한다.

7. choco install cmake, choco install git, choco install doxygen.install, choco install python, choco install make, choco install llvm 명령어를 순차적으로 실행해서 CMake 활용에 필요한 프로그램들을 깔아준다. (llvm은 선택이라지만 디스크 용량이 충분하다면 걍 깔자) 여기서 중요한 점은 cmake 시스템 환경변수가 올바르게 등록되었는지를 알아야 한다. 

8. CMake를 설치해도 PowerShell 관리자 모드에서 cmake --version 명령어가 제대로 실행되지 않는다면 환경변수가 제대로 설정되지 않은 것이니 시스템 속성 -> 고급 탭 -> 환경 변수 -> 시스템 변수 -> Path 에 cmake.exe가 위치한 폴더 경로를 추가해주자. (보통 "C:\Program Files\CMake\bin" 이거다.)

9. VS Code를 설치하고 확장에서 franneck94 유저가 만들어 놓은 "C/C++ Extension Pack", "Coding Tools Extension Pack"을 설치하고 VS Code를 재시작해준다.

10. 설치된 항목 중에 중요한 것은 C/C++, Doxygen Documentation Generator, Cmake Tools 인데 Cmake Tools 이 녀석이 사용되는 상태인지 확인을 해보고 사용안되는 것으로 되어 있다면 사용 상태로 바꿔놓는다.

# VS Code에서 CMake 활성화

1. 진행할 프로젝트 폴더를 VS Code로 열고 CMakeLists.txt 파일을 추가해준다. 반드시 이름을 대소문자까지 모두 동일하게 만들어야 한다.  그 다음 cpp 파일 아무거나 만들어 준다.

2. "보기" -> "명령 팔레트"에 들어가 "CMake:Configure"를 선택한다. 

3. VS Code 하단에 위치하는 파란색 바에 활성화된 kit의 종류를 선택하는 부분이 있는데 이를 눌러서 cpp를 빌드할 적절한 컴파일러를 선택한다. 그리고 밑의 두가지 방식 중 하나를 선택하면 되는데 버튼 하나 눌러서 되는 인터페이스 방식이 더 편해보이지만 복잡해지면 명령어 방식이 편하게 느껴질 수가 있다.

[VS Code 내부 터미널을 통한 사용법]
4.1 터미널에서 mkdir build로 현재 프로젝트 내부에 build라는 이름의 폴더를 만든다. 이미 build 폴더가 있으면 하지 않아도 된다.

4.2 cd build 명령어로 build 폴더로 이동하고 cmake .. 명령어로 CMakeLists.txt가 위치한 부분을 타겟으로 cmake 세팅을 해준다.

4.3 cmake --build . 명령어로 현재 build 폴더에 실행 파일을 생성한다.

[VS Code 인터페이스를 이용한 사용법]
5.1 VS Code 하단에 위치하는 파란색 바에 톱니바퀴 아이콘과 Build 글자가 같이 묶여있는 버튼을 눌러서 빌드하면 된다.

6. 빌드에 오류가 있다면 과거 빌드에 사용된 컴파일러 버전이 달라서 발생한 문제일 가능성이 크니 build 폴더를 완전히 삭제하고 다시 빌드해보면 된다.

7. Debug, Realse 빌드 전환은 VS Code 하단에 위치하는 파란색 바에 CMake: [Debug]: Ready 이렇게 쓰여있는 곳이 있을텐데 이를 눌러서 변경해주면 된다.

# CMakeLists.txt 문법

CMakeLists.txt에서 주석은 #으로 달아준다. [ex. #이건 CMake 파일이다!!]

cmake_minimum_required -> CMake의 최소 사용 버전을 설정해준다. [ex. cmake_minimum_required(VERSION 3.16)]

project -> 현재 프로젝트의 속성과 관련된 정보를 적는다. 예를 들어 project(CppProjectTemplate VERSION 1.0.0 LANGUAGES C CXX) 이렇게 적혔다면 프로젝트 이름은 CppProjectTemplate이고 해당 프로젝트의 버전은 1.0.0이며 프로젝트에서 쓰이는 언어는 C 또는 CXX(C++)이다.

add_executable -> 실행 파일을 만드는데 사용되는 모든 파일들(.cpp만)을 적는다. 꼭 앞에 실행 파일의 이름을 적어주어야 한다. [ex. add_executable(MyExecutable main.cpp) 이렇게 하면 MyExecutable.exe를 만들겠다는 것이다.]

add_library -> 라이브러리를 만들기 위한 명령이다. 현재 프로젝트에 종속될 라이브러리와 관련된 파일들(.cpp만)을 적는다. 꼭 앞에 생성될 라이브러리 이름과 링크 방식을 적어야 한다. 예를 들어 add_library(MyLibrary STATIC my_lib.cpp) 이렇게 적었다면 정적 링크(STATIC)할 MyLibrary 이름을 가진 라이브러리를 생성하는데 필요한 파일은 my_lib.cpp라는 것이다.

target_link_libraries -> 실행 파일이 원활하게 실행될 수 있게 관련된 라이브러리를 링크 시키기 위한 명령이다. 예를 들어 target_link_libraries(MyExecutable PUBLIC MyLibrary)를 하면 MyExecutable 실행 파일에 MyLibrary 라이브러리가 PUBLIC으로 링크된다.

target_include_directories -> 헤더 파일을 정의하기 손쉽게 하기 위해 사용하는 명령이다. 예를 들어 밑과 같은 경로에 파일들이 위치한다고 하자.
- HelloWorld
	- CMakeLists.txt
	- app
		- main.cpp
		- CMakeLists.txt
	- src
		- my_lib.cpp
		- my_lib.h
		- CMakeLists.txt
일단 CMake를 원활하게 사용하려면 무조건 각 폴더마다 CMakeLists.txt 파일이 존재해야 한다.
CMake는 항상 프로젝트 최상위 폴더부터 CMakeLists.txt를 읽어가면서 명령 순서대로 하위 폴더를 탐색하며 빌드를 수행한다는 것을 명심하자.
my_lib.h, my_lib.cpp는 MyLibrary라는 라이브러리를 빌드하는 곳에 쓰인다고 하자. 
main.cpp는 MyExecutable이라는 실행 파일을 빌드하는 곳에 쓰이고 MyExecutable은 MyLibrary를 실행에 필요로 한다고 하자.
이 상황에서 main.cpp가 my_lib.h를 include하고 싶을 땐 #include "../src/my_lib.h" 이렇게 선언해야 하는데 이게 여간 귀찮은 게 아니다.
이를 해결해 주려면 src 폴더 내부 CMakeLists.txt에 target_include_directories(<해당 명령 전에 미리 생성된 실행 파일 or 라이브러리, 즉 여기서는 MyLibrary> PUBLIC "./")를 선언해주면 main.cpp에서 #include "my_lib.h" 혹은 #include <my_lib.h> 만으로 my_lib.h를 참조할 수 있다.
더 정확하게 작동 원리를 말하자면 app 폴더 내 CMakeLists.txt에 target_link_libraries(MyExecutable PUBLIC MyLibrary) 이게 있다고 하면 해당 app 폴더 내의 파일들은 MyLibrary가 종속된 MyExecutable 실행 파일을 만드는 곳에 쓰이는 것이다. 이때 src 폴더 내 CMakeLists.txt에 target_include_directories(MyLibrary PUBLIC "./") 이게 있다고 하면 app 폴더 내 모든 cpp, h 파일에 헤더 참조를 할 때 "어떠한_긴_경로.../HelloWorld/src/" 경로가 추가되어 #include <my_lib.h> 이러한 문구가 가능해진다. "어떠한_긴_경로.../HelloWorld/src/" 경로가 추가될 수 있었던 이유는 target_include_directories(MyLibrary PUBLIC "./") 명령이 쓰인 CMakeLists.txt 파일의 위치가 "어떠한_긴_경로.../HelloWorld/src/" 였고 target_include_directories에 쓰인 경로가 "./"로 현재 위치인 "어떠한_긴_경로.../HelloWorld/src/"를 나타내고 있으며 app 폴더 내 CMakeLists.txt에 target_link_libraries 명령에서 MyLibrary가 종속되어 있어서 가능한 것이다. 즉 target_include_directories(MyLibrary PUBLIC "./") 명령으로 인해 MyLibrary를 종속하고 있는 곳이라면 모두 헤더 참조를 할 때 #include <my_lib.h> 이렇게 쓸 수 있는 것이다.

add_subdirectory -> 하위 폴더에 빌드 관련 CMakeLists.txt가 있는 경우 이를 인식하도록 상위 폴더의 CMakeLists.txt에 add_subdirectory를 해주어야 한다. CMake가 파일을 타고 타고 내려갈 때 꼭 필요한 명령이기 때문에 파일이 따로 없고 폴더만 포함하는 폴더에도 CMakeLists.txt 파일을 만들어 줘야 한다. 그리고 더 중요한 것은 add_subdirectory 명령의 순서이다.
만약 app 폴더 내부에 있는 파일들이 MyExecutable이라는 실행 파일을 만드는데 해당 실행 파일이 MyLibrary라는 라이브러리를 요구한다고 해보자. 근데 MyLibrary는 src 폴더 내부에 있는 파일들을 통해 생성된다. 이 경우 app 폴더와 src 폴더를 모두 가지고 있는 상위 폴더에서는 MyLibrary가 먼저 만들어져야 한다는 것을 알고 add_subdirectory(src) 후에 add_subdirectory(app) 를 해줘야 한다.

set -> cmake에서 변수를 지정할 때 사용된다. 예를 들어 set(LIBRARY_NAME "MyLibrary") 라고 하면 C++로 따지면 std::string LIBRARY_NAME = "MyLibrary"; 이거랑 똑같은 것이다. 만약에 set(LIBRARY_NAME MyLibrary) 이렇게 "를 때고 변수 지정을 한다면 CMake가 적절한 변수 형태를 유추해서 저장을 한다. 이 경우에는 MyLibrary가 문자열이니 문자형으로 저장을 할 것이다.
set은 단순히 변수를 저장할 때도 쓰이지만 CMake 자체에 내장되어 있는 변수들의 값을 바꿀 때도 사용된다. 예를 들어 프로젝트에서 C++ 17을 사용하고 싶다면 set(CMAKE_CXX_STANDARD 17) 이렇게 해주면 된다.
변수명을 지을 때 주의할 점은 모두 대문자로 지어야 한다는 것이다. 변수명을 사용할 때는 ${LIBRARY_NAME} 이렇게 사용한다. [ex. target_include_directories(${LIBRARY_NAME} PUBLIC "./")]

option -> CMake에서 bool형 변수를 생성할 때 사용된다. 변수명, 변수 설명, 디폴트 값 순으로 정의한다. [option(COMPILE_EXECUTABLE "This is COMPILE_EXECUTABLE hint!" OFF)]

if(조건) -> if문이 존재한다. if문을 사용했으면 endif()로 꼭 닫아줘야 한다. else문, else if문은 else(), elseif()로 사용한다.

message -> message("문자열")로 사용한다. 빌드 시점이 아니라 CMake 세팅 시점에 출력된다. 그니까 "cmake .." 이러한 명령을 수행할 때 볼 수 있다.

configure_file ->

# CMakeLists.txt 사전변수

CMAKE_CXX_STANDARD -> C++ 표준 버전 정의 [ex. set(CMAKE_CXX_STANDARD 17)]

CMAKE_CXX_STANDARD_REQUIRED -> C++ 표준 버전 정의된 것을 필수로 요구할 것이냐 아니냐. 만약 프로젝트 빌드 유저의 환경이 C++17을 지원하지 않는 경우 CMAKE_CXX_STANDARD_REQUIRED 변수가 OFF로 되어 있으면 CMAKE_CXX_STANDARD가 17로 정의되어 있더라도 프로젝트 빌드 유저 환경에 맞는 다른 C++ 버전이 채택되어 그걸로 빌드된다. [ex. set(CMAKE_CXX_STANDARD_REQUIRED ON)]

CMAKE_CXX_EXTENSIONS -> 특정 컴파일러 확장 기능을 사용하냐 안하냐를 결정한다. msvc만의 기능이 있고 gcc만의 기능이 있는데 이러한 특수한 기능을 사용할 것이냐를 물어보는 것이다. 크로스 플랫폼 빌드가 빌요한 프로젝트에서는 걍 사용하지 말자. [ex. set(CMAKE_CXX_EXTENSIONS OFF)]

CMAKE_BINARY_DIR -> 빌드 산출물이 생성되는 위치의 경로

# CMake 명령어 문법

자세한 명령어 내용은 https://runebook.dev/ko/docs/cmake/ 이곳에서 찾아보자.
세팅은 빌드 전 cmake 환경 설정을 한다고 생각하면 되고 빌드는 말 그대로 코드 산출물이 발생되는 것이다.

## 세팅 옵션

-S 옵션은 프로젝트의 root directory 경로가 위치해야 한다. (보통 첫 CMakeLists.txt가 위치하는 곳, 프로젝트 폴더 최상위 경로)

-B 옵션은 빌드 후 생성되는 파일들이 위치할 폴더 경로가 적혀야 한다.

예를 들어 C:/VS_CODE_PROJECTS/HelloWorld/CMakeLists.txt 이렇게 위치하고 있다면 "cmake -S C:/VS_CODE_PROJECTS/HelloWorld -B C:/VS_CODE_PROJECTS/HelloWorld/build "명령어를 수행해 cmake 프로젝트를 세팅해주면 된다.

-D 옵션은 CMakeLists.txt에 정의된 변수를 커맨드 라인으로 세팅할 때 사용된다. 예를 들어 CMake 환경 세팅을 진행할 때 C++14 버전으로 빌드 설정을 하고싶다면 "cmake .. -DCMAKE_CXX_STANDARD=14" 이러한 명령어를 입력하면 된다. 주의할 점은 -D와 특정 변수명 사이에 띄어쓰기가 없이 붙여써야 한다는 것이다.

-G 옵션은 CMake가 빌드 구성 파일을 만들 수 있도록 도와주는 생성기를 지정하는 곳에 쓰인다. 그러면 생성기가 뭐냐고 물어볼 수 있는데 CMake는 혼자서 링크 종속성에 대한 정보를 컴파일러에게 전달하지 못한다. 이유는 링크 종속성을 전달하는 방식이 플랫폼마다 다르기 때문인데 Mac과 같은 Unix 기반에서는 Unix Makefiles가 생성기 역할을 해주고 Windows에서는 Visual Studio가 이 역할을 해준다. 물론 Ninja와 같이 크로스 플랫폼 생성기도 있지만 프로젝트가 돌아가는 컴퓨터에 Ninja가 깔려있을 것이라는 보장이 없지 않은가? 따라서 자신이 빌드할 때 특정한 생성기를 이용하여 빌드하고 싶다면 -G 옵션을 사용하면 된다.
예를 들어 cmake -S .. -B . -G "Visual Studio 16 2019" 이렇게 하면 CMake관련 빌드 구성 파일들이 Visual Studio 2019를 통해 생성된다. 
생성기에 대한 자세한 답변은 https://stackoverflow.com/questions/25941536/what-is-a-cmake-generator 요기에 잘 설명되어 있다.

## 빌드 옵션

--build 옵션은 프로젝트를 빌드할 때 수행하는 명령어다. "--build 특정경로"로 사용하면 된다.

--target 옵션은 특정 타겟을 정해서 해당 타겟만 빌드할 수 있다. 예를 들어 CMakeLists.txt에 MyLibrary라는 라이브러리가 정의되어 있다면 cmake --build . --target MyLibrary를 하면 MyLibrary와 그 라이브러리에 종속된 모듈들만 빌드된다.

