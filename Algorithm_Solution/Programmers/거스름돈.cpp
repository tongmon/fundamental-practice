#include <bits/stdc++.h>
using namespace std;

/*
https://programmers.co.kr/learn/courses/30/lessons/12907
거스름돈 문제....
Dp실력이 한참이나 딸리다는 것을 이 문제를 풀고 알았다.
Dp 문제 계속해서 풀어봐야겠다.
이 문제의 점화식은 Dp[목표 금액] = 가짓수를 기반으로 한다.
만약에 동전 1,2,3이 있다고 하고 3원을 만든다고 하자.
3원을 만들때 동전 1원을 써서 만들게 되면 나머지 2원을 채워야 한다.
3원을 만들때 동전 2원을 써서 만들게 되면 나머지 1원을 채워야 한다.
3원을 만들때 동전 3원을 써서 만들게 되면 나머지 0원을 채워야 한다.
이 말들을 점화식으로 풀어써 보면 Dp[3] = Dp[0] + Dp[1] + Dp[2]가 된다.
Dp[0]은 3원을 사용했을 때 맞춰줘야 하는 나머지 금액이고 이는 1가지이다.
아무 돈을 쓰지 않는 경우 밖에 없기 때문이다.
Dp[1]은 2원을 사용하고 나머지 금액이고 이를 맞춰줘야 3원이 된다.
Dp[2]도 마찬가지 이다.
따라서 Dp[3]을 구하기 위해서는 Dp[0],Dp[1],Dp[2]가 선행으로 구해져 있어야 한다.
똑같이 Dp[2]를 구하기 위해서는 Dp[1]이 선행으로 구해져 있어야 한다.
결과적으로 Dp[목표 금액] = Dp[목표 금액] + Dp[목표 금액 - 지불한 돈]이 되고
이렇게 구현한 것이 밑의 코드와 같다.
*/

int Dp[100001];

int solution(int n, vector<int> money) {
	Dp[0] = 1;
	for (auto M : money) {
		for (int i = M; i <= n; i++) {
			Dp[i] = (Dp[i] + Dp[i - M]) % 1000000007;
		}
	}
	return Dp[n];
}