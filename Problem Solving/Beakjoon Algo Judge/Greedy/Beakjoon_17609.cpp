#include <bits/stdc++.h>
using namespace std;

/*
https://www.acmicpc.net/problem/17609
펠린드롬 문자열 검사 문제인데 하나를 빼도 펠린드롬이 되는
경우를 판별하는 문제다.
처음에 간단하게 앞에서 부터 체크해오는 포인터 i가 뒤에서 오는 포인터 j와
글자가 다르다면 일단 하나 뺀 유사한 펠린드롬이라면 i == j - 1 아니면
j = i + 1 이러한 경우 밖에 없을 것이기에 계속 앞으로 진행하면서 비교를 진행하여
판별을 했으나 틀렸다.
일단 인덱스 문제가 많았다. j = i + 1 이런 경우에는 사실상 최종 문자 길이에서 1이 빠진
상태로 다시 펠린트롬을 판별하는 것이기에 문자 길이에 따른 중간점이 달라진다.
반례로는 abwbb가 되겠다. a를 지우면 a를 가리키던 인덱스가 w를 가리켜야 하는데 반절 이상이 되어
바로 반복문을 탈출해버리고 이게 유사한 펠린드롬 이라는 판단을 한다.
그리고 반대에서 지우면 펠린드롬이고 앞에서 지우면 펠린드롬이 아닌 경우도 있기에 한번씩 다 돌려봐야 했다.
따라서 이러한 인덱스 하나 차이로 인한 예외가 골치아파서 그냥
처음에 펠린드롬 검사한번 돌리고 여기서 펠린드롬이 아니였다면....
1. 앞글자가 빠졌다고 치고 펠린드롬 검사 돌리기
2. 위의 검사에서도 펠린드롬이 아니라고 판단되면 뒷 글자가 빠졌다고 치고 펠린드롬 검사 진행
3. 둘 중에 하나라도 펠린드롬이라고 판별나면 유사 펠린드롬인 것이고 아니면 그냥 아무 특성도 없는 문자열
이러한 절차를 거쳐서 풀었다.
중간에 인덱스 처리할 때 인덱스만 가지고 사이즈의 반절을 판단 하는 경우
(시작 인덱스 + 끝 인덱스) / 2 이렇게 처리했었는데 이게 아니라
(시작 인덱스 + 끝 인덱스 + 1) / 2 이게 맞는 표현이다. 
실제 인덱스 세보면서 해보면 답 나온다. 이런 실수 하지 말자
이 문제를 통해 문자열 인덱스 처리에 대한 감을 다져간다.
*/

string In;
int N;

int main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> N;
	while (N) {
		cin >> In;
		int Pelin = 0, Size = In.size() / 2;
		int St1 = 0, En1 = 0, St2 = 0, En2 = 0;
		for (int i = 0, j = In.size() - 1; i < Size; i++, j--) {
			if (In[i] != In[j]) {
				Pelin = 1;
				St1 = i + 1; En1 = j;
				St2 = i; En2 = j - 1;
				break;
			}
		}
		Size = (En1 - St1 + 1) / 2 + St1;
		for (int i = St1, j = En1; i < Size && Pelin; i++, j--)
		{
			if (In[i] != In[j]) {
				Pelin = 2; break;
			}
		}
		Size = (En2 - St2 + 1) / 2 + St2;
		bool flag = 0;
		for (int i = St2, j = En2; i < Size && Pelin == 2; i++, j--)
		{
			if (In[i] != In[j]) {
				flag = 1; break;
			}
		}
		if (!flag && Pelin > 0)
			Pelin = 1;
		cout << Pelin << "\n";
		N--;
	}
}